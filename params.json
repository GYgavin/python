{
  "name": "Python",
  "tagline": "",
  "body": "PYTHON 简明教程\r\n@author 刘振伟\r\n@QQ 570962906\r\nPYTHON 创始人: Guido van Rossum, 在 Python 界被誉为仁慈的独裁者。\r\n借鉴了 unix shell ,c 的特点\r\n1989 圣诞期间发布, python 已经有 20 年的历史了,比 java 早很多, java 第一个版本才是 1994 年发布的。\r\n2000 年 10.16 python2.0 发布,此时 python 才真正成为一个功能完善,非常好用的语言\r\n2008 年 12 月 3 日, python3 发布,相比与 python2 而言,改变比较大,不兼容 python2. 目前是两个版本共存的\r\npython 的定位:\r\n解释型的通用语言 ( 操作系统内核等没有解释器存在,是不能在内核或硬件上使用 python 的 )\r\n优雅 明确 简单,在 Python 中做某件事有且只有一个最优解\r\n使用范围: web (国内的豆瓣,知乎等等) , 自动化脚本,数据分析 (spark 上原生支持 Python) 等\r\npython 的实现与版本:\r\n通常所说的 python 是由 C 语开发,是官方的版本\r\njython 是由 java 写的,运行在 jvm 上 , 可以与现有的 JAVA 库无缝的兼容\r\nIronPython 是运行在 .net 平台上的 , 兼容 .net 库\r\nPyPy 是用 python 写成的 python( 在科学计算上较广泛使用 ) ,在 python 中有一个很大的 ” 缺陷 “ , GIL 全局库解释器锁, PyPy 就是为了解决这个问题而存在\r\n的。\r\n大版本之间不向前兼容 (python3 与 python2)\r\n本次课以 python2.7 来讲 , 这也是目前使用最为广泛的版本\r\n安装 PYENV\r\n大多数 linux 上已经安装了 python 环境,但不同的发行版 linux 安装的 python 版本会有不同 ,pyenv 管理多版本的 python.\r\n我们工作上有时候需要使用到多版本的 python,\r\nyum -y install gcc gcc-c++ make git patch openssl_devel zlib-devel readline-devel sqlite-devel bzip2-devel\r\n安装 pyenv:\r\n作者已经给提供了一个安装脚本,下载下来直接运行即可:\r\nhttps://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer\r\n配置环境变量:\r\n[root@yeahmonitor ~]# cat /etc/profile.d/pyenv.sh\r\nexport PATH=\"$HOME/.pyenv/bin:$PATH\"\r\neval \"$(pyenv init -)\"\r\neval \"$(pyenv virtualenv-init -)\"\r\n[root@yeahmonitor ~]# . /etc/profile\r\n使用 pyenv 安装 python2.7.5\r\n[root@yeahmonitor ~]# pyenv install 2.7.5\r\n#rhel7 和 centos 7 中系统自带的 python 就是 2.7.5 的版本\r\n[root@yeahmonitor ~]# pyenv install pypy-1.9\r\n# 安装 pypy-1.9\r\n卸载 pyenv uninstall xxx\r\n告诉 pyenv 当前目录使用哪个版本的 python\r\n[root@yeahmonitor python]# pyenv local 2.7.5\r\n[root@yeahmonitor python]# pyenv rehash# 重建环境变量 , 告诉 pyenv 当前使用该版本\r\n[root@yeahmonitor python]# pyenv version\r\n2.7.5 (set by /root/python/.python-version)\r\n# 其他目录下还是使用的是系统自带的版本 , 这里是 7 的 linux 所以全是 2.7.5\r\n管理全局的 python : pyenv global 2.7.5\r\n打开一个 python shell:[root@yeahmonitor python]# python\r\nPython 2.7.5 (default, Jun 17 2014, 18:11:42)\r\n[GCC 4.8.2 20140120 (Red Hat 4.8.2-16)] on linux2\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>>\r\n安装 easy_install,\r\nwget https://bootstrap.pypa.io/ez_setup.py -O - | python\r\nIpython 是对 python shell 的增强 ( 自动补全,更清晰的查看文档等 ) :\r\n[root@yeahmonitor python]# easy_install ipython\r\n打开 ipython shell:\r\nipython\r\n变量命名:\r\n(下划线或字母) + (任意数目的字母、数字或下划线)\r\n变量名必须以下划线或字母开头,而后面接任意数目的字母、数字或下划线。\r\n区分大小写: SPAM 和 spam 不同\r\n禁止使用保留字\r\npython 基础\r\n最初步骤\r\n使用交互式 python\r\n挑选一个合适的编辑器或者 IDE\r\n使用源文件\r\n可执行的 python\r\nunicode 支持\r\n简单的示例:\r\n[root@yeahmonitor python]# cat hello.py\r\nprint \"hello world\"\r\n[root@yeahmonitor python]# python hello.py\r\nhello world\r\n从第一行往下依次执行代码\r\n示例二:以可执行文件运行\r\n[root@yeahmonitor python]# cat hello.py\r\n#!/usr/bin/env python\r\nprint \"hello world\"\r\n[root@yeahmonitor python]# chmod +x hello.py\r\n[root@yeahmonitor python]# ./hello.py\r\nhello world\r\n输出中文:\r\n[root@yeahmonitor python]# cat hello.py\r\n#!/usr/bin/env python\r\nprint \"hello world\"\r\nprint \" 你好,世界 !\"\r\n[root@yeahmonitor python]# ./hello.py\r\nFile \"./hello.py\", line 4\r\nSyntaxError: Non-ASCII character '\\xe4' in file ./hello.py on line 4, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details\r\n# 显式的指定编码:\r\n[root@yeahmonitor python]# cat hello.py\r\n#!/usr/bin/env python\r\n# coding=utf-8 # 显式指定编码为 utf-8\r\nprint \"hello world\"\r\nprint \" 你好,世界 !\"\r\n[root@yeahmonitor python]# ./hello.py\r\nhello world\r\n你好,世界 !关于脚本中的第一行内容 :\r\n#!/usr/bin/python 这种写法表示直接引用系统的默认的 Python 版本,这样的话 python 程序移植到其他机器上可能运行的时候有问题,因为别人系统默\r\n认的 Python 版本与你预期的并不一致。\r\n#!/usr/bin/env python 这种写法表示,引用环境变量里面自定义的 Python 版本,具有较强的可移植性,推荐这种写法。\r\n测试不写第一行内容是否可行。。。。在什么情况下正常运行,在什么情况下会报错,结合 shell 来讲。\r\n基本概念\r\n字面常量 ( 看到的是什么样的 ,就是什么样 ), 如 \"hello world\"\r\n单独出现的数字,字符串等\r\n1,\"abc\",['a',1]\r\n字面常量是解释器里面的一块内存\r\n单独的字面常量是无意义的 , 当一块内存没有变量在引用的时候会被自动释放。\r\n变量\r\n变量是一个指向一段内存的符号\r\npython 里所有的变量都是引用 ,\r\n变量命名规范(由数字,字母,下划线组成 , 不能以数字开头 , 关键字不能作为变量名 )\r\n数据类型\r\npython 是一种强类型的动态语言,每一个数据都有一个类型,不同类型之间的数据不能做运算,如数字和字符不能相加 . 所谓的动态语言是指,数据类型可以\r\n在运算时改变 .\r\n>>> v1 = 1\r\n>>> type(v1)\r\n<type 'int'>\r\n>>> v1 = \"string\"\r\n>>> type(v1)\r\n<type 'str'>\r\n# 在 C 中是绝对不能这么做的\r\n# 不同类型的数据不能做运算\r\n>>> v1 = \"string\"\r\n>>> type(v1)\r\n<type 'str'>\r\n>>> v2 = 1\r\n>>> v1+v2\r\nTraceback (most recent call last):\r\nFile \"<stdin>\", line 1, in <module>\r\nTypeError: cannot concatenate 'str' and 'int' objects\r\n数据类型,不同的数据类型的二进制是不一样的,为了能让解释器知道这段内存是什么,所以要定义数据类型,也就是规范了数据存放的二进制格式。\r\n在 python 中分为数字类型和字符串类型,数字又分为:整型 , 长整型和浮点型\r\n>>> a = 1.1\r\n>>> type(a)\r\n<type 'float'>\r\n# 字符串连接\r\n>>> s1 = 'hello'\r\n>>> s2 = ' world'\r\n>>> s = s1 + s2\r\n>>> s\r\n'hello world'\r\n类型转化, >>> i = 1 >>> float(i) 1.0 #float 要比 int 精度要高,从低精度向高精度转换是没有数据损失的,从高精度转向低精度会有损失。\r\n对象,在 python 中万物皆对象,所有的都是对象\r\n运算符与表达式\r\n算术运算符 + * / ** // % 位操作运算符 << >> & | ^ ~ 比较运算符 < <= >= == > != 逻辑运算符 and or not 赋值运算符 = 其他运算符\r\n数学运算符,\r\n>>> 10 /3 # 两个整型相除的时候,等到的还是整型 , 会有精度损失\r\n3\r\n# 将其中一个转换为 float, 会等到一个 float 型\r\n>>> 10 /float(3)\r\n3.3333333333333335\r\n# 幂运算\r\n>>> 2**101024\r\n# 除法取整\r\n>>> 10 // 3.0\r\n3.0 # 只取整部分\r\n# 取模运\r\n>>> 10 % 3\r\n1\r\n位运算符 :\r\n>>> 2 << 3 #2 左移 3 位, (10 --->10 000)\r\n16\r\n# 位运算速度比较快\r\n# 按位与 &\r\n>>> 3 & 2\r\n2\r\n# 安位或 |\r\n>>> 3 | 2\r\n3\r\n# 异或 , 两个位置相同取 1 ,不同则取 0\r\n>>> 3 ^ 2\r\n1\r\n比较运算符,与其他语言都相同\r\n逻辑运算符,与其他语言类似,只是写法不同\r\n赋值运算符,与其他语言相同 a = 1 , 想 a 符号指向该数据存在的内存\r\n表达式\r\n由运算符,连接起来的变量或者常量,构成表达式 , 如 a = 1 和 c = a1 + b2\r\n优先级\r\n单目运算符高于双目运算符, not 例外 ; 单目运算符,只有一个数的运算符,如正负号,按位取反,not .python 里没有三目运算符\r\n算数运算符高于位运算符 :\r\n位运算符高于比较运算符\r\n比较运算符高于逻辑运算符\r\n赋值运算符优先级最低\r\n>>> 1 + 2 << 2\r\n12\r\n>>> 3 << 2\r\n12\r\n# 先加再移位\r\n# 位运算符高于比较运算符\r\n>>> 2 << 2 < 6\r\nFalse\r\n() 可以提升运算符的优先级 , 某些情况为了程序的可读性也要有小括号\r\n程序结构\r\n顺序结构\r\n分支结构 ( if ,else,elif )\r\nif 语句\r\nif condition:\r\nexpression\r\n示例:\r\n[root@yeahmonitor python]# cat if.py\r\n#!/usr/bin/env python\r\nif 3 < 5:\r\nprint \"3 less than 5\" # 语句块里面可以是多个语句if 3 > 4:\r\nprint \"3 greate than 4\"\r\n[root@yeahmonitor python]# ./if.py\r\n3 less than 5\r\nelse 子句\r\nif condition:\r\nexpression\r\nelse:\r\nexpression\r\nif 语句里面还可以嵌套 if.python 是允许语句的嵌套的。 else 子句总是 if 语句的最后一个分支。不能出现在 elif 子句前面。\r\nelif 字句\r\nif condition:\r\nexpresssion\r\nelif condition:\r\nexpression\r\n# 可以有多个 elif 子句 , 但是一旦其中一个分支没执行了,就不会往下再去匹配执行了。\r\npython 中没有 switch 语句。只能用 elif 模拟 switch.\r\n循环结构\r\nwhile 语句\r\nfor 语句\r\nbreak 语句\r\ncontinue 语句\r\nelse 子句\r\nwhile 循环\r\nwhile condition:\r\nexpression\r\n示例:\r\n[root@yeahmonitor python]# cat while.py\r\n#!/usr/bin/env python\r\na = 3\r\nwhile a <= 10:\r\nprint a\r\na += 1\r\n[root@yeahmonitor python]# chmod +x while.py\r\n[root@yeahmonitor python]# ./while.py\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\nfor 语句\r\nfor item in iterator:\r\nexpression\r\npython 中 for 语句后边是要跟一个迭代器(列表,元组等)的。\r\nrange 可以得到一个列表。range(1,10)\r\n[root@yeahmonitor python]# cat for.py\r\n#!/usr/bin/env python\r\nfor x in range(10):\r\nprint x\r\n[root@yeahmonitor python]# chmod +x for.py\r\n[root@yeahmonitor python]# ./for.py\r\n0\r\n12\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\nbreak 语句\r\n只能出现在循环块中\r\n用于跳出当前循环\r\n示例:\r\n[root@yeahmonitor python]# cat for.py\r\n#!/usr/bin/env python\r\nfor x in range(10):\r\nprint x\r\nif x == 5:\r\nbreak\r\n[root@yeahmonitor python]# ./for.py\r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\ncontinue 语句\r\n只出现在循环中\r\n跳出当前循环循环操作,接着执行下一次循环\r\nPython 内置容器\r\n列表\r\nlist\r\n定义和初始化 list\r\n# 定义个空列表\r\nIn [1]: li = []\r\nIn [2]: type(li)\r\nOut[2]: list\r\n# 初始化 list,list 中的元素没有类型要求,可以是任何类型\r\nIn [3]: li = [1,2,'a',['a',4]]\r\nIn [4]: li\r\nOut[4]: [1, 2, 'a', ['a', 4]]\r\n列表的下标\r\npython 中列表的下标是从 0 开始的。\r\nIn [4]: li\r\nOut[4]: [1, 2, 'a', ['a', 4]]\r\nIn [5]: li[2]\r\nOut[5]: 'a'\r\nIn [6]: li[4]\r\n---------------------------------------------------------------------------\r\nIndexError\r\nTraceback (most recent call last)\r\n<ipython-input-6-5889debca501> in <module>()\r\n----> 1 li[4]\r\nIndexError: list index out of range\r\n# 得到 list 长度\r\nIn [7]: len(li)\r\nOut[7]: 4in 关键字\r\n在 for 循环中使用表示遍历 list 中的所有元素:\r\nIn [8]: for x in li:\r\n...:\r\nprint x\r\n...:\r\n1\r\n2\r\na\r\n['a', 4]\r\nin 也可以作为一个二元操作符使用 , 查找某个元素是否在 list 中存在:\r\nIn [9]: 'a' in li\r\nOut[9]: True\r\ndel 删除 list 中某个元素 :\r\nIn [10]: li\r\nOut[10]: [1, 2, 'a', ['a', 4]]\r\nIn [11]: del li[0]\r\nIn [12]: li\r\nOut[12]: [2, 'a', ['a', 4]]\r\n在 python 中一切皆为对象,显然, list 也是对象,针对于列表对象来说,常用的操作:\r\nIn [13]: dir(li)\r\nOut[13]:\r\n['__add__',\r\n'__class__',\r\n.........\r\n'__str__',\r\n'__subclasshook__',\r\n'append',\r\n'count',\r\n'extend',\r\n'index',\r\n'insert',\r\n'pop',\r\n'remove',\r\n'reverse',\r\n'sort']\r\n查看 list 对象 append 方法的帮助信息:\r\nIn [14]: help(li.append)\r\nIn [15]: li\r\nOut[15]: [2, 'a', ['a', 4]]\r\nIn [16]: li.append(666)\r\nIn [17]: li\r\nOut[17]: [2, 'a', ['a', 4], 666]\r\nextend 方法,接受一个迭代器,将迭代器的所有元素追加到 list 中:\r\nIn [17]: li\r\nOut[17]: [2, 'a', ['a', 4], 666]\r\nIn [18]: li.extend(['abc','cba'])\r\nIn [19]: li\r\nOut[19]: [2, 'a', ['a', 4], 666, 'abc', 'cba']\r\ninsert 方法,li.insert(2,'x') , li.insert(-1,'mm') , 在某个索引下标之前插入某个数据。\r\nremove 方法,li.remove('a') , 从 list 中移除某个元素。\r\npop 方法,接受一个可选参数 index,remove 下标所指向的元素,并将钙元素返回,li.pop() , li.pop(2) :\r\nIn [19]: li\r\nOut[19]: [2, 'a', ['a', 4], 666, 'abc', 'cba']In [20]: li.pop()\r\nOut[20]: 'cba'\r\nIn [21]: li\r\nOut[21]: [2, 'a', ['a', 4], 666, 'abc']\r\nIn [22]: li.pop(2)\r\nOut[22]: ['a', 4]\r\nIn [23]: li\r\nOut[23]: [2, 'a', 666, 'abc']\r\ncount 方法,返回某个值在 list 出现的次数 , li.count('a')\r\nindex 方法,返回第一个匹配 value 的下标 :\r\nIn [28]: li\r\nOut[28]: [2, 'a', 666]\r\nIn [29]: li.index('a')\r\nOut[29]: 1\r\nIn [30]: li.index('b')\r\n---------------------------------------------------------------------------\r\nValueError\r\nTraceback (most recent call last)\r\n<ipython-input-30-4639cb7d3bae> in <module>()\r\n----> 1 li.index('b')\r\nValueError: 'b' is not in list\r\n# 还可以指定起始和结束查找的范围参数 li.index('a',2,6)\r\nIn [33]: li\r\nOut[33]: [2, 'a', 666, 'a', 'a', 'b']\r\nIn [34]: li.index('a',2)\r\nOut[34]: 3\r\nsort 方法,直接修改 list 内容,不返回值 . li.sort() , 还可以接受三个可选参数。L.sort(cmp=None, key=None, reverse=False)\r\nreverse 方法。li.reverse()\r\nlist 的切片\r\nli[i],li[a:b],li[a:e:b]-- 第三个参数为步长 ,index 每次加几,默认为 1\r\nIn [40]: li\r\nOut[40]: ['b', 'a', 'a', 'a', 666, 2]\r\nIn [41]: li[2:4]\r\nOut[41]: ['a', 'a']\r\n####\r\nIn [43]: li[:2]\r\nOut[43]: ['b', 'a']\r\n###\r\nIn [44]: li[4:]\r\nOut[44]: [666, 2]\r\n## 对 list 做一次深 copy\r\nIn [45]: li[:]\r\nOut[45]: ['b', 'a', 'a', 'a', 666, 2]\r\n####\r\nIn [46]: li[2:4:2]\r\nOut[46]: ['a']\r\n## 用切片实现 list 翻转\r\nIn [47]: li\r\nOut[47]: ['b', 'a', 'a', 'a', 666, 2]\r\nIn [48]: li[::-1]\r\nOut[48]: [2, 666, 'a', 'a', 'a', 'b']\r\n# 得到下标为偶数的 list\r\nIn [50]: li\r\nOut[50]: ['b', 'a', 'a', 'a', 666, 2]\r\nIn [51]: li[::2]\r\nOut[51]: ['b', 'a', 666]\r\n# 得到下标为奇数的值\r\nIn [52]: li[1::2]\r\nOut[52]: ['a', 'a', 2]列表的切片操作是一个复制操作,并不对原始列表进行修改。\r\n元祖 tuple\r\n定义和初始化元祖\r\nIn [1]: t = ()\r\nIn [2]: type(t)\r\nOut[2]: tuple\r\nIn [3]: t = (1,2,3)\r\nIn [4]: t\r\nOut[4]: (1, 2, 3)\r\n元祖也支持下标和切片操作。\r\n元祖是不可变对象,不能对元祖的内容做修改\r\nIn [4]: t\r\nOut[4]: (1, 2, 3)\r\nIn [5]: t[1]\r\nOut[5]: 2\r\nIn [6]: t[1] = 100\r\n---------------------------------------------------------------------------\r\nTypeError\r\nTraceback (most recent call last)\r\n<ipython-input-6-4f066cd5e53f> in <module>()\r\n----> 1 t[1] = 100\r\nTypeError: 'tuple' object does not support item assignment\r\n元祖的不可变是相对的,因为元祖里面的内容可以是各种类型,如,元祖的元素值为列表:\r\nIn [7]: t1 = ([2,3,4],[19,23,45])\r\nIn [8]: t1\r\nOut[8]: ([2, 3, 4], [19, 23, 45])\r\nIn [9]: t1[0][2]\r\nOut[9]: 4\r\nIn [10]: t1[0][2] = 100 #list 的值是可变的,可以被修改的\r\nIn [11]: t1\r\nOut[11]: ([2, 3, 100], [19, 23, 45])\r\ncount , index 操作\r\nIn [12]: t\r\nOut[12]: (1, 2, 3)\r\nIn [13]: t.count(2)\r\nOut[13]: 1\r\nIn [14]: t.index(3)\r\nOut[14]: 2\r\n元组支持切片操作与列表的切片操作一样。\r\n集合 set\r\n定义和初始化集合\r\n列表和元组都是有序的,但是集合是无序的。\r\nIn [17]: s = {1,2,3}\r\nIn [18]: type(s)\r\nOut[18]: set\r\n集合中的元素不重复\r\nIn [19]: s = {1,1,1,12,2,2,3,4}In [20]: s\r\nOut[20]: {1, 2, 3, 4, 12}\r\npython 根据集合中的每个元素的 hash 值来判断是否重复,所以集合中的每个元素必须是可 hash 的对象。在 python 中如果一个对象有一个__hash__ 的方法,\r\n表示该对象可 hash.\r\nIn [21]: 1.__hash__ # 整数 1 的对象有该方法,但是 __hash__ 方法不能直接调用。\r\n1.__hash__\r\nhash() 函数直接返回某个对象的 hash 值。如hash(1)\r\n集合不支持切片操作。\r\n集合的操作:\r\nadd 操作\r\nIn [21]: s\r\nOut[21]: {1, 2, 3, 4, 12}\r\nIn [22]: s.add(100)\r\nIn [23]: s\r\nOut[23]: {1, 2, 3, 4, 12, 100}\r\nupdate 操作 , 迭代器作为参数,将迭代器中的所有元素追加到集合中\r\nIn [23]: s\r\nOut[23]: {1, 2, 3, 4, 12, 100}\r\nIn [24]: s.update([101,102,103])\r\nIn [25]: s\r\nOut[25]: {1, 2, 3, 4, 12, 100, 101, 102, 103}\r\nremove 删除某个元素,若该元素不存在则报错\r\ndiscard 删除某个元素,若该元素不存在则不做任何操作。\r\npop() 随机删除某个元素,并返回该元素\r\nclear 清空集合。s.clear()\r\n集合的运算\r\ndifference 两个集合的差集,不修改原来的两个集合\r\nIn [26]: s1 = {1,2,3,4,5,'a'}\r\nIn [27]: s2 = {4,5,7,8,'b','c'}\r\nIn [28]: s1.diff\r\ns1.difference\r\ns1.difference_update\r\nIn [28]: s1.difference(s2)\r\nOut[28]: {1, 2, 3, 'a'}\r\n# 减号可以直接求两个集合的差集\r\nIn [29]: s1 - s2\r\nOut[29]: {1, 2, 3, 'a'}\r\ndifference_update 两个集合的差集,但修改原来的集合 , 不返回值\r\nIn [30]: s1\r\nOut[30]: {1, 2, 3, 4, 5, 'a'}\r\nIn [31]: s2\r\nOut[31]: {4, 5, 7, 8, 'b', 'c'}\r\nIn [32]: s1.difference_update(s2)\r\nIn [33]: s1\r\nOut[33]: {1, 2, 3, 'a'}\r\nIn [34]: s2\r\nOut[34]: {4, 5, 7, 8, 'b', 'c'}intersection 两个集合的交集,返回值,不修改原来的集合\r\nintersection_update 两个集合的交集,无返回值,修改原来的集合\r\n& , s1 & s2 直接求两个集合的交集\r\nunion 两个集合的并集\r\n| , s1 | s2 也是求两个集合的并集\r\nisdisjoint 查看两个集合是否有交集,返回 bool, s1.isdisjoint(s2)\r\nissubset 查看是否是子集\r\n列表,元组,集合之间的转换\r\nlist 函数\r\nIn [35]: list()\r\nOut[35]: []\r\nIn [36]: list('hello')\r\nOut[36]: ['h', 'e', 'l', 'l', 'o']\r\ntuple 函数\r\nset 函数\r\nIn [37]: t = (1,2,3)\r\nIn [38]: type(t)\r\nOut[38]: tuple\r\nIn [39]: list(t)\r\nOut[39]: [1, 2, 3]\r\n将 list 转换为 set 的时候,若列表中存在重复元素,则移除重复的元素。\r\n迭代器 iterator\r\niter 函数 , 构造集合。\r\nnext 方法依次返回迭代器的值\r\nIn [42]: li\r\nOut[42]: [1, 2, 3, 4, 5]\r\nIn [43]: it = iter(li)\r\nIn [44]: it.next()\r\nOut[44]: 1\r\nIn [45]: it.next()\r\nOut[45]: 2\r\n当所有的元素都返回完的时候,会抛出一个StopIterator 的异常。\r\nlist,tuple,set 都属于集合。\r\nfor 语句,当将一个列表传递给for 语句的时候,实际上for 语句会将列表转换为迭代器,然后隐示的地执行该迭代器。\r\n字典 dict\r\n定义与初始化 In [46]: d = {}\r\nIn [47]: type(d)\r\nOut[47]: dict\r\nIn [48]: d = {'a':1,'v':'k'}\r\nIn [49]: d\r\nOut[49]: {'a': 1, 'v': 'k'}\r\n在字典中 key 是不允许重复的,所以字典中的 key 必须是可 hash 的对象。\r\n字典的操作\r\nkeys 将字典的所有 key 作为一个列表返回In [50]: d\r\nOut[50]: {'a': 1, 'v': 'k'}\r\nIn [51]: d.keys()\r\nOut[51]: ['a', 'v']\r\niterkeys 将字典的所有 key 作为一个迭代器返回\r\nIn [52]: d.iterkeys()\r\nOut[52]: <dictionary-keyiterator at 0x12ff7e0>\r\nIn [53]: it = d.iterkeys()\r\nIn [54]: it.next()\r\nOut[54]: 'a'\r\nvalues 返回一个列表,该列表是所有元素的值\r\nIn [55]: d\r\nOut[55]: {'a': 1, 'v': 'k'}\r\nIn [56]: d.values()\r\nOut[56]: [1, 'k']\r\nitems , 返回一个列表,列表中的每个元素是一个元组,元组中的两个值分别是 key 和 value\r\nIn [57]: d\r\nOut[57]: {'a': 1, 'v': 'k'}\r\nIn [58]: d.items()\r\nOut[58]: [('a', 1), ('v', 'k')]\r\n遍历一个字典:\r\nIn [59]: for v in d.values():\r\n....:\r\nprint v\r\n....:\r\n1\r\nk\r\nIn [60]: for k,v in d.items():\r\n....:\r\nprint \"%s => %s\" % (k,v)\r\n....:\r\na => 1\r\nv => k\r\nget , 按照 key 取值,若存在则返回,否则返回 None\r\nIn [61]: d.get('a')\r\nOut[61]: 1\r\n还可以给get 传递第二个参数,表示若 key 不存在,则返回某个值。\r\nIn [65]: d.get('xx',100)\r\nOut[65]: 100\r\nhas_key , 判断某个 key 是否存在\r\nIn [63]: d.has_key('a')\r\nOut[63]: True\r\nIn [64]: d.has_key('aa')\r\nOut[64]: False\r\n给字典增加一个键值对:\r\nIn [66]: d = {}\r\nIn [67]: d['c'] = 1\r\nIn [68]: d\r\nOut[68]: {'c': 1}\r\nIn [69]: d['xx'] = 100\r\nIn [70]: dOut[70]: {'c': 1, 'xx': 100}\r\nIn [71]: d['xx'] = 200\r\nIn [72]: d\r\nOut[72]: {'c': 1, 'xx': 200}\r\nupdate 操作\r\nIn [73]: d\r\nOut[73]: {'c': 1, 'xx': 200}\r\nIn [74]: d.update({'a':1,'b':2})\r\nIn [75]: d\r\nOut[75]: {'a': 1, 'b': 2, 'c': 1, 'xx': 200}\r\npython 字典为引用传值,如:\r\nIn [76]: d\r\nOut[76]: {'a': 1, 'b': 2, 'c': 1, 'xx': 200}\r\nIn [77]: d1 = d\r\nIn [78]: d1['a'] = 200\r\nIn [79]: d1\r\nOut[79]: {'a': 200, 'b': 2, 'c': 1, 'xx': 200}\r\nIn [80]: d\r\nOut[80]: {'a': 200, 'b': 2, 'c': 1, 'xx': 200}\r\ncopy 操作:重新复制一个字典\r\nIn [81]: d\r\nOut[81]: {'a': 200, 'b': 2, 'c': 1, 'xx': 200}\r\nIn [82]: d2 = d.copy()\r\nIn [83]: d2\r\nOut[83]: {'a': 200, 'b': 2, 'c': 1, 'xx': 200}\r\nIn [84]: d2['a'] = 300\r\nIn [85]: d2\r\nOut[85]: {'a': 300, 'b': 2, 'c': 1, 'xx': 200}\r\nIn [86]: d\r\nOut[86]: {'a': 200, 'b': 2, 'c': 1, 'xx': 200}\r\nIn [87]: id(d)\r\nOut[87]: 19662176\r\nIn [88]: id(d2)\r\nOut[88]: 19501072\r\nIn [89]: id(d1)\r\nOut[89]: 19662176\r\n列表解析\r\n[expression for item in iterator] 一个最基本的列表解析 , 返回一个列表\r\n在expression 可以使用item 变量\r\n返回一个迭代器\r\n(expression for item in terator)\r\nIn [90]: li = [1,2,3]\r\nIn [91]: l = (x+1 for x in li)\r\nIn [92]: l\r\nOut[92]: <generator object <genexpr> at 0x12fa730>\r\nIn [93]: l.next()\r\nOut[93]: 2In [94]: l.next()\r\nOut[94]: 3\r\n迭代器是惰性求值,只有用到了才会计算该值,否则不会。列表是先求出所有值的。所以当数据大的时候迭代器有较好的性能。\r\n带条件的列表解析\r\n[expression for item in iterator if condition] ,当满足条件的时候才会 append 到列表中,并返回。当变为小括号的时候,就会返回一个迭代器。\r\nIn [95]: li\r\nOut[95]: [1, 2, 3]\r\nIn [96]: [x for x in li if x % 2 ==0]\r\nOut[96]: [2]\r\n带多个条件 [expression for item in iterator if conditionX if conditionY]\r\n带多个迭代器(笛卡尔积与列表解析):[expr for x in IterX for y in IterY] , 类似于两个嵌套的 for 循环操作\r\nIn [99]: [(x,y) for x in [1,2,3] for y in [1,3]]\r\nOut[99]: [(1, 1), (1, 3), (2, 1), (2, 3), (3, 1), (3, 3)]\r\n列表解析的性能远高于循环语句。\r\n作业:猜数字游戏:\r\n1.\r\n2.\r\n3.\r\n4.\r\n随机产生要猜的数字 (1-100)\r\n输入,用于接收用户输入的数字\r\n循环,如果没有猜对则循环接收输入,并打出提示信息\r\n猜到数字或猜测次数达到一定次数后( 6 次)打印失败并退出\r\n[root@localhost ~]# cat g_num.py\r\n#!/usr/bin/env python\r\n#coding=utf-8\r\nimport random\r\nsecret = random.randint(1,100)\r\nguess,tries = 0,0\r\nprint u\" 你好,请你给出一个 1-99 的数字,试下你的运气如何?你只有六次机会哟 ~ !! \"\r\nwhile guess != secret and tries < 6:\r\nprint u\" 请给出你猜的数字试多少: \"\r\nguess_str = raw_input()\r\ng = int(guess_str)\r\nif g == secret:\r\nprint u\"wawawa...... 好吧,你猜中了,你说怎么办吧? \"\r\nbreak\r\nelif g < secret:\r\nprint str(g),u\"Are you a pig? 太小了。 \"\r\nelif g > secret:\r\nprint str(g),u\"Are you a pig? 太大了。 \"\r\ntries += 1\r\nelse:\r\nprint u\" 都猜了 6 次了,还没猜到。你能 chua!~~~\"\r\nprint u\" 哥来告诉你,这个数字是 :\",str(secret)\r\n这里需要注意的是,假如说,用户输入的是一个字符串怎么办???\r\n函数\r\n简单函数的定义\r\ndef func_name():\r\n\"\"\" comment \"\"\"\r\nexpression\r\nfunc_name() # 调用函数\r\n示例:\r\n[root@yeahmonitor ~]# cat func.py#!/usr/bin/env python\r\ndef func():\r\nprint \"Hi,Dog\"\r\nfunc()\r\n局部变量和全局变量\r\n作用域:变量生效的范围\r\n局部变量:在函数内定义的变量,局部变量作用域为函数体\r\n全局变量:定义在函数之外,在函数内使用 global 关键字标记,全局变量的作用域为整个模块\r\n全局变量应尽量少用,但是有些配置性的信息可以直接使用全局变量定义较为方便调用\r\n变量覆盖\r\n示例,局部变量:\r\n#!/usr/bin/env python\r\narg = 10 # 这里是一个全局变量\r\ndef func():\r\narg = 2 # 这里是一个局部变量,与外边的 arg 是两个不同的变量\r\nprint arg\r\nfunc()\r\nprint arg\r\n示例,使用全局变量:\r\n#!/usr/bin/env python\r\narg = 10\r\ndef func():\r\nglobal arg # 这里使用 global 定义 arg 是一个全局变量,下边的赋值操作会覆盖函数体外的赋值操作。\r\narg = 6\r\nprint arg\r\nfunc()\r\nprint arg\r\n在函数体内可以直接调用全局变量:\r\n#!/usr/bin/env python\r\narg = 10\r\ndef func():\r\nprint arg\r\nfunc()\r\nprint arg\r\n# 在函数体内没有对 arg 变量有任何声明和赋值的操作,所以这里的 arg 调用的是全局变量\r\n带参数的函数\r\ndef func_name(args):\r\nexpression\r\nfunc_name(values)\r\n# 参数可以是一个或者多个\r\n示例:\r\ndef funcArg(i):\r\nprint i #i 作为参数传递进来,是一个局部变量\r\nfuncArg('hello')\r\n多个参数用逗号隔开:\r\ndef funcArg(i,m,k):\r\nprint i,m,k\r\nfuncArg('hello',1,2)\r\n位置参数和关键字参数def func_name(arg1,arg2):\r\nexpression\r\n通常的调用方式为func_name(v1,v2) , 但是如果参数非常多,传值的时候一定要记好每个参数的顺序。这种是位置参数。 也可以以关键字的行为传递参\r\n数func_name(arg1=v1,arg2=v2) , 顺序就不那么重要了,这就是关键字参数。\r\ndef funcArg(i,m,k):\r\nprint i,m,k\r\nfuncArg(m = 'hello',k=1,i=2)\r\n关键字参数和位置参数也可以混合使用:\r\nfunc_name(v1,arg2=v2)\r\ndef funcArg(i,m,k):\r\nprint i,m,k\r\nfuncArg(m = 'hello',k=1,i=2)\r\nfuncArg(20,k=100,m='hi')# 这里的位置参数必须在关键字参数之前 , 否则会有语法错误。\r\n默认参数\r\n对某一个或多个参数指定一个默认值:\r\ndef func_name(arg1,arg2=v2):\r\nexpression\r\ndef func_name(arg1=v1,arg2=v2):\r\nexpression\r\n示例:\r\ndef func(i,j,k=1):\r\nprint i,j,k\r\nfunc(2,200)\r\nfunc(1,2,3)# 默认参数有传值,会覆盖掉默认值\r\n在函数定义的时候,带默认值的参数必须放在不带默认值参数的后边。\r\n可变参数\r\n在 python 中也支持可变参数。\r\n参数有两种,一种是位置参数,另一种是关键字参数。那么可变参数同样支持这两种方式。\r\n可变位置参数:\r\ndef func_name(*args):\r\n# 函数中的 args 是一个元组\r\nexpression\r\nfunc_name(v1,v2,v3...)\r\n示例:\r\ndef func(*args):\r\nprint type(args)\r\nfor x in args:\r\nprint x,\r\nprint\r\nfunc(1,2,2,3,'a','v')\r\n[root@yeahmonitor ~]# python func.py\r\n<type 'tuple'>\r\n1 2 2 3 a v\r\n*args 这种方式定义的方式,只能以位置传递参数进去,可变位置参数。\r\n可变关键字参数:\r\ndef func_name(**kwargs):\r\n# 函数中的 kwargs 是一个字典\r\nexpression\r\nfunc_name(k1=v1,k2=v2,k3=v3...)示例:\r\ndef func(**kwargs):\r\nprint type(kwargs)\r\nfor k,v in kwargs.items():\r\nprint \"%s => %s\" % (k,v)\r\nfunc(i=1,j=2,k='aa')\r\n[root@yeahmonitor ~]# python func.py\r\n<type 'dict'>\r\ni => 1\r\nk => aa\r\nj => 2\r\n混合使用:\r\n非可变参数必须要在可变参数之前\r\ndef func(i,j,*args):\r\nprint i,j\r\nfor x in args:\r\nprint x\r\nfunc(1,2,'1',\"a\",\"abc\")\r\n可变位置参数要在关键字参数之前\r\n参数解包\r\n参数解包发生在函数调用时 .\r\n#!/usr/bin/env python\r\ndef func(i,j,k):\r\nprint i,j,k\r\nli = [1,2,3]\r\nfunc(li[0],li[1],li[2]) # 传统的调用方法\r\nfunc(*li) # 将列表解包并传递进去 , 这里是一个解包的过程。\r\n* 用于解包序列为位置参数。\r\n** 用于解包字典为关键字参数:\r\n#!/usr/bin/env python\r\ndef func(i,j,k):\r\nprint i,j,k\r\nli = [1,2,3]\r\n#func(li[0],li[1],li[2])\r\nfunc(*li)\r\nd = {'i':2,'j':100,'k':300}\r\nfunc(**d)\r\n函数返回值\r\nreturn 关键字\r\ndef func(i):\r\ni *= 2\r\nreturn i\r\nj = func(2)\r\nprint j\r\n可以返回任何对象\r\n可以变相返回多值def func(i):\r\nj = i * 2\r\nk = i * 9\r\nreturn j,k # 这里返回两个值,调用的时候需要有两个变量接受 , 这里其实是将 j,k 构造成一个元组返回。\r\nx,y = func(2)\r\nprint x,y\r\n默认返回值 , 当函数中没有return 关键字的时候,函数会默认返回None , 所以所有的 python 函数都有返回值。\r\n递归函数\r\n函数体内调用自身的函数\r\n计算一个值的阶乘\r\ndef fact(n):\r\nif n <= 1:\r\nreturn n\r\nreturn fact(n-1) * n\r\nf = fact(10)\r\nprint f\r\n递归函数需要有合适的退出条件\r\npython 中函数递归的最大深度为 1000\r\npython 中应尽量避免递归 , 绝大多数递归都是可以转换为迭代的。\r\n求阶乘的函数转换为迭代:\r\ndef fact2(n):\r\nret = 1\r\nfor x in range(n,1,-1):\r\nret *= x\r\nreturn ret\r\nprint fact2(10)\r\npython 中的迭代要比递归快很多。\r\n以上为函数的基本定义知识点。\r\n在 python 中,函数是一等对象,可以像值一样的赋值,作为函数的返回值返回。\r\n函数作为参数\r\ndef func1(arg):\r\nexpression\r\ndef func2(func):\r\nexpression\r\nfunc2(func1)\r\n示例:\r\n#!/usr/bin/env python\r\ndef func(f):\r\nprint \"this is func,i will call %s\" % f.__name__\r\nf()\r\ndef func2():\r\nprint \"this is func2\"\r\nfunc(func2)\r\nX.__name__ 获取某个对象的名称, python 中函数也是一个对象\r\n高阶函数\r\n像上边那样,以函数对象作为参数的函数叫高阶函数\r\n下边介绍三个内置的高阶函数:\r\nfilter : filter(function or none,seq) 当函数返回为 true 的时候,会将序列的当前值加进来。\r\nIn [1]: li = [1,2,3,4,5,6,7,8,10]In [2]: def f(x):\r\n...:\r\nreturn x % 2 == 0\r\n...:\r\nIn [3]: filter(f,li)\r\nOut[3]: [2, 4, 6, 8, 10]\r\n# 这类似于列表解析\r\nmap : 对列表中的所有元素执行一个函数\r\nIn [4]: def f2(x):\r\n...:\r\nreturn x * 2\r\n...:\r\nIn [5]: li\r\nOut[5]: [1, 2, 3, 4, 5, 6, 7, 8, 10]\r\nIn [6]: map(f2,li)\r\nOut[6]: [2, 4, 6, 8, 10, 12, 14, 16, 20]\r\n# 这个也可以使用列表函数实现\r\nreduce :\r\nIn [1]: li = [1,2,3,4]\r\nIn [2]: def sum(x,y):\r\n...:\r\nreturn x * y\r\n...:\r\nIn [3]: reduce(sum,li)\r\nOut[3]: 24\r\n函数嵌套定义\r\ndef ext(): def internal(): expression\r\n返回函数\r\ndef external():\r\ndef internal():\r\nexpression\r\nreturn internal\r\n示例:\r\ndef ext_func():\r\nprint \"this is ext\"\r\ndef inn_func():\r\nprint \"this is inn\"\r\nreturn inn_func\r\nf = ext_func() # 这里会返回函数 inn_func\r\nf()\r\n有了这些基础,那么加入我们要计算一个函数的执行时间,但又不想破坏这个函数,不想给这个函数增加其他额外的代码?\r\n#!/usr/bin/env python\r\nimport time\r\nimport datetime\r\ndef func(arg):\r\ntime.sleep(arg)\r\ndef timeIt(func):\r\ndef warp(arg):\r\nstart = datetime.datetime.now()\r\nfunc(arg)\r\nend = datetime.datetime.now()\r\ncost = end - start\r\nprint \"execute %s spend %s\" % (func.__name__,cost.total_seconds())\r\nreturn warp\r\nnew_func = timeIt(func) # 这里会返回一个新的函数\r\nnew_func(3) # 调用新的函数 , 并传值进去这样就以一种非侵入式的方式包装的这个函数,并且增加了我们需要的功能。这就是 python 中的装饰器。 类似于 java 的注解。\r\n装饰器\r\n主要就是解耦合,例如上边的我不需要计算函数的执行时间了,那么我直接调用该函数即可。\r\n在 python 中对装饰器提供更好的方法。\r\n@timeIt\r\ndef func(arg):\r\ntime.sleep(arg)\r\nfunc(arg)\r\n示例:\r\n#!/usr/bin/env python\r\nimport time\r\nimport datetime\r\ndef timeIt(func):\r\ndef warp(arg):\r\nstart = datetime.datetime.now()\r\nfunc(arg)\r\nend = datetime.datetime.now()\r\ncost = end - start\r\nprint \"execute %s spend %s\" % (func.__name__,cost.total_seconds())\r\nreturn warp\r\n@timeIt # 这里是 python 提供的一个语法糖\r\ndef func(arg):\r\ntime.sleep(arg)\r\nfunc(3)\r\n在这里func 函数被装饰器包装,所以func.__name__ 返回的名字并不是 'func' 了,而是被装饰器改变为warp 。要想保留原来函数的__name__ , __doc__ 等元信\r\n息,需要做一下修改:\r\n#!/usr/bin/env python\r\nimport time\r\nimport datetime\r\nimport functools\r\ndef timeIt(func):\r\n@functools.wraps(func) # 增加这一行 , 将原函数作为值传递进去,表示将原函数的 __name__,__module__,__doc__ 信息更新到装饰器里\r\ndef warp(arg):\r\nstart = datetime.datetime.now()\r\nfunc(arg)\r\nend = datetime.datetime.now()\r\ncost = end - start\r\nprint \"execute %s spend %s\" % (func.__name__,cost.total_seconds())\r\nreturn warp\r\n@timeIt\r\ndef func(arg):\r\ntime.sleep(arg)\r\nfunc(3)\r\nprint func.__name__\r\nlambda 匿名函数 :\r\nPython 虽然不是一种函数式编程语言,但仍然给予了函数式编程很大的重视。接下来就聊一下 Python 函数式编程的知识,其中本文要说的是匿名函数\r\nlambda 。\r\nPython 使用 lambda 关键字创造匿名函数。所谓匿名,意即不再使用 def 语句这样标准的形式定义一个函数。这种语句的目的是由于性能的原因,在调用时绕\r\n过函数的栈分配。其语法是:\r\nlambda [arg1[, arg2, ... argN]]: expression\r\n其中,参数是可选的,如果使用参数的话,参数通常也会在表达式之中出现。\r\nlambda 语句的使用方法 ( 无参数 ):In [1]: def func():\r\n...:\r\nreturn 1\r\n...:\r\nIn [2]: lambda:1 # 等价于上边定义的函数 , 不接受参数,直接返回值\r\nOut[2]: <function __main__.<lambda>>\r\nIn [3]: f = lambda:1 #lambda 会返回一个函数,将该函数赋值给变量\r\nIn [4]: f() # 调用函数\r\nOut[4]: 1\r\n声明一个带参数的匿名函数:\r\nIn [5]: f = lambda x,y:x+y # 带有两个参数\r\nIn [6]: f(10,2)\r\nOut[6]: 12\r\nIn [7]: f = lambda x,y=10:x+y # 带默认值的参数\r\nIn [8]: f(19)\r\nOut[8]: 29\r\nIn [9]: f(19,2)\r\nOut[9]: 21\r\nIn [10]: f = lambda *x:map(lambda x:x+10,x)# 可变位置参数\r\nIn [11]: f(1,2,3,4)\r\nOut[11]: [11, 12, 13, 14]\r\nIn [12]: f(*[2,3,4,5])\r\nOut[12]: [12, 13, 14, 15]\r\n示例:\r\n[root@yeahmonitor ~]# cat lam.py\r\n#!/usr/bin/env python\r\nfunc = {\r\n\"add\":lambda\r\n\"sub\":lambda\r\n\"mul\":lambda\r\n\"div\":lambda\r\n}\r\nx,y:x+y,\r\nx,y:x-y,\r\nx,y:x*y,\r\nx,y:x/y\r\nprint func[\"add\"](1,2)\r\nprint func[\"sub\"](3,2)\r\nprint func[\"mul\"](4,5)\r\nprint func[\"div\"](10,3)\r\n# 执行结果\r\n[root@yeahmonitor ~]# python lam.py\r\n3\r\n1\r\n20\r\n3\r\ngenerator 生成器\r\n生成器概念\r\n生成器不会把结果保存到一个系列中,而是保存生成器的状态,在每次进行迭代时计算并返回一个值,值到遇到StopIteration 异常结束。\r\n生成器语法\r\n生成器表达式:\r\n与列表解析语法相似,只不过把列表解析的 [] 换成 ()\r\n生成器表达式能做的事,列表解析基本都能处理;只不过在需要处理的序列比较大时,列表解析比较费内存。\r\n简单的生成器表达示例:\r\nIn [1]: gen = (x**2 for x in range(5))\r\nIn [2]: gen\r\nOut[2]: <generator object <genexpr> at 0x193e910>In [3]: gen.next()\r\nOut[3]: 0\r\nIn [4]: gen.next()\r\nOut[4]: 1\r\nIn [5]: gen.next()\r\nOut[5]: 4\r\nIn [6]: gen.next()\r\nOut[6]: 9\r\nIn [7]: gen.next()\r\nOut[7]: 16\r\nIn [8]: gen.next()\r\n---------------------------------------------------------------------------\r\nStopIteration\r\nTraceback (most recent call last)\r\n<ipython-input-8-b2c61ce5e131> in <module>()\r\n----> 1 gen.next()\r\nStopIteration:\r\n生成器表达式,并不能实现较为复杂的功能。所以在工作中一般都是直接使用生成器函数。\r\n生成器函数:\r\n在函数中如果出现了 yield 关键字,那么该函数就不再是普通函数,而是生成器函数。\r\n生成器函数可以产生一个无限的序列,列表解析是无法这么做的。\r\nyield 的作用就是把一个函数变成一个 generator, 带有 yield 的函数不再是一个普通函数, Python 解释器会将其视为一个 generator 。\r\n产生无穷奇数的生成器函数:\r\n#!/usr/bin/env python\r\ndef odd():\r\nn = 1\r\nwhile True:\r\nyield n\r\nn += 2\r\nod = odd()\r\ncount = 0\r\nfor i in od:\r\nif count >= 5: break\r\nprint i\r\ncount += 1\r\n[root@walter ~]# python gen.py\r\n1\r\n3\r\n5\r\n7\r\n9\r\n题外话: 生成器是包含有 iter() 和 next() 方法的,所以可以直接使用 for 来迭代 . 查看帮助信息:\r\n# 定义一个简单的生成器函数\r\nIn [1]: def odd():\r\n...:\r\nyield 1\r\n...:\r\nIn [2]: o = odd()\r\n# 查看其帮助信息\r\nIn [3]: help(o)\r\nodd\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n= class generator(object)\r\nMethods defined here:\r\n__getattribute__(...)\r\nx.__getattribute__('name') <==> x.name\r\n__iter__(...)# 包含 iter 方法\r\nx.__iter__() <==> iter(x)|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n|\r\n__repr__(...)\r\nx.__repr__() <==> repr(x)\r\nclose(...)\r\nclose() -> raise GeneratorExit inside generator.\r\nnext(...)# 包含 next 方法,所以可以直接用在 for 语句\r\nx.next() -> the next value, or raise StopIteration\r\nsend(...)# 使用该方法传值到生成器中\r\nsend(arg) -> send 'arg' into generator,\r\nreturn next yielded value or raise StopIteration.\r\nthrow(...)# 使用该方法抛一个异常进去\r\nthrow(typ[,val[,tb]]) -> raise exception in generator,\r\nreturn next yielded value or raise StopIteration.\r\n由上边帮助信息可以看出,我们可以完全按照迭代器的循环方式遍历一个生成器。\r\n示例说明:\r\n#!/usr/bin/env python\r\ndef odd():\r\nn = 1\r\nwhile True:\r\nyield n\r\nn += 2\r\nod = odd()\r\ncount = 0\r\nfor i in od:\r\nif count >= 5: break\r\nprint i\r\ncount += 1\r\n# 在 for 循环执行的时候,每次都会执行 odd 函数内的代码。\r\n# 执行到 yield n 时,将 n 的值返回出去,此时函数内的代码不再往下执行 , 挂起状态,但会保存函内变量的相关信息。\r\n# 下次迭代的时,从 yield n 的下一条语句, n += 2 开始执行,\r\n# 这个时候 n 的值是之前保留的值,函数体内的 while 循环继续执行,当再次执行到 yield n 的时候,将 n 返回出去,此时的 n 是已经计算过 n+=2 了\r\n# 看起来就好像一个函数在正常执行的过程中被 yield 中断了数次,每次中断都会通过 yield 返回当前的迭代值。\r\nyield 与 return:\r\n在一个生成器中,如果没有 return ,则默认执行到函数完毕时返回 StopIteration ;\r\n>>> def g1():\r\n...\r\nyield 1\r\n...\r\n>>> g=g1()\r\n>>> next(g)\r\n# 第一次调用 next(g) 时,会在执行完 yield 语句后挂起,所以此时程序并没有执行结束。\r\n1\r\n>>> next(g)\r\n# 程序试图从 yield 语句的下一条语句开始执行,发现已经到了结尾,所以抛出 StopIteration 异常。\r\nTraceback (most recent call last):\r\nFile \"<stdin>\", line 1, in <module>\r\nStopIteration\r\n>>>\r\n如果遇到 return, 如果在执行过程中 return ,则直接抛出 StopIteration 终止迭代。\r\n>>> def g2():\r\n...\r\nyield 'a'\r\n...\r\nreturn\r\n...\r\nyield 'b'\r\n...\r\n>>> g=g2()\r\n>>> next(g)\r\n# 程序停留在执行完 yield 'a' 语句后的位置。\r\n'a'\r\n>>> next(g)\r\n# 程序发现下一条语句是 return ,所以抛出 StopIteration 异常,这样 yield 'b' 语句永远也不会执行。\r\nTraceback (most recent call last):\r\nFile \"<stdin>\", line 1, in <module>\r\nStopIteration\r\nclose()\r\n手动关闭生成器函数,后面的调用会直接返回 StopIteration 异常。>>> def g4():\r\n...\r\nyield 1\r\n...\r\nyield 2\r\n...\r\nyield 3\r\n...\r\n>>> g=g4()\r\n>>> next(g)\r\n1\r\n>>> g.close()\r\n>>> next(g)\r\n# 关闭后, yield 2 和 yield 3 语句将不再起作用\r\nTraceback (most recent call last):\r\nFile \"<stdin>\", line 1, in <module>\r\nStopIteration\r\n** send()**\r\n生成器函数最大的特点是可以接受外部传入的一个变量,并根据变量内容计算结果后返回。 这是生成器函数最难理解的地方,也是最重要的地方,实现后面\r\n我会讲到的协程就全靠它了。\r\ndef gen():\r\nvalue=0\r\nwhile True:\r\nreceive=yield value\r\nif receive=='e':\r\nbreak\r\nvalue = 'got: %s' % receive\r\ng=gen()\r\nprint(g.send(None))\r\nprint(g.send('aaa'))\r\nprint(g.send(3))\r\nprint(g.send('e'))\r\n执行结果:\r\n0\r\ngot: aaa\r\ngot: 3\r\nTraceback (most recent call last):\r\nFile \"h.py\", line 14, in <module>\r\nprint(g.send('e'))\r\nStopIteration\r\n执行流程:\r\n1. 通过 g.send(None) 或者 next(g) 可以启动生成器函数,并执行到第一个 yield 语句结束的位置。此时,执行完了 yield 语句,但是没有给 receive 赋值。 yield\r\nvalue 会输出初始值 0 注意:在启动生成器函数时只能 send(None), 如果试图输入其它的值都会得到错误提示信息。\r\n2. 通过 g.send(‘aaa’) ,会传入 aaa ,并赋值给 receive ,然后计算出 value 的值,并回到 while 头部,执行 yield value 语句有停止。此时 yield value 会输出 ”got:\r\naaa” ,然后挂起。\r\n3. 通过 g.send(3) ,会重复第 2 步,最后输出结果为 ”got: 3′′\r\n4. 当我们 g.send(‘e’) 时,程序会执行 break 然后推出循环,最后整个函数执行完毕,所以会得到 StopIteration 异常。\r\n总结:\r\n1. 按照鸭子模型理论,生成器就是一种迭代器,可以使用 for 进行迭代。\r\n2. 第一次执行 next(generator) 时,会执行完 yield 语句后程序进行挂起,所有的参数和状态会进行保存。再一次执行 next(generator) 时,会从挂起的状态开\r\n始往后执行。在遇到程序的结尾或者遇到 StopIteration 时,循环结束。\r\n3. 可以通过 generator.send(arg) 来传入参数,这是协程模型。\r\n4. next() 等价于 send(None)\r\n作业 待定\r\nIO 与文本处理\r\n标准 IO 设备的操作\r\nprint 语句\r\nprint 语句可以将内容输出到标准输出上,如print 'hello' ;除此之外,print 还可以将内容输出到的文件对象里:\r\nIn [2]: import sys\r\nIn [3]: print >> sys.stderr,'hello' # 将内容输出到标准错误中\r\nhello\r\nprint 函数 , 包含在__future__ 模块中 :In [4]: from __future__ import print_function\r\nIn [5]: type(print) # 此时的 print 不再是个语句,而是个函数,这个时候 print 不能再像上边那么使用了\r\nOut[5]: builtin_function_or_method\r\n示例:\r\nIn [6]: print(\"hello\",\"world\")\r\nhello world\r\nIn [7]: print(\"hello\",\"world\",sep=\"\\n\")\r\nhello\r\nworld\r\nraw_input 函数,是一个内置函数,从标准输入读入内容 :\r\nIn [8]: s = raw_input()\r\nhello\r\nIn [9]: s\r\nOut[9]: 'hello\r\nIn [10]: s = raw_input(\"Plz input >\")\r\nPlz input >hello world\r\nIn [11]: s\r\nOut[11]: 'hello world'\r\nopen 函数与 file 对象\r\nopen() 是一个内置函数,open(name[,mode[,buffering]]) , 其实是对 file 的一个封装 , 返回一个 file 对象。下边详细介绍下 open 函数的 modes 参数都有哪些:\r\nr 以读的方式打开,定位到文件开头 , 默认的 mode\r\nr+ 以读写的方式打开,定位文件开头 , 可以写入内容到文件\r\nw 以写的方式打开,打开文件的时候会清空文件的内容,并且不能读\r\nw+ 以读写的方式打开,定位到文件头,并且打开文件的时候也会清空文件的内容\r\na 以写的方式打开,定位到文件的末尾,是一个追加的操作 , 但并不允许读\r\na+ 以读写的方式打开,定位到文件的末尾,追加的方式。\r\n在使用以上 mode 打开文件的时候,如果增加了b 模式,表示以二进制方式打开\r\n示例:\r\nIn [12]: f = open('/tmp/test.txt','r')\r\nIn [13]: f.read()\r\nOut[13]: 'test\\n'\r\nIn [14]: f.close()# 打开的文件必须要关闭,\r\n# 否则随着文件打开的数量,会消耗掉所有的文件描述符\r\nIn [15]: f = open('/tmp/test.txt','r+')\r\nIn [16]: f.write('123')\r\nIn [18]: f.close()\r\n[root@yeahmonitor ~]# cat /tmp/test.txt\r\n123t\r\nfile 对象的操作:\r\nread() 表示读取文件所有内容到内存里,可以带一个可选参数表示读取多少字节。当打开较大文件的时候慎用,或者是要加个参数表示读取多少字\r\n节 . f.read() 或者f.read(4)# 读取四个字节\r\nreadline() 读取一行内容\r\nIn [27]: f = open('/tmp/test.txt','r')\r\nIn [28]: f.readline()\r\nOut[28]: 'test\\n'\r\nIn [29]: f.readline()\r\nOut[29]: 'test\\n'\r\nIn [30]: f.readline()\r\nOut[30]: 'test\\n'\r\nIn [31]: f.readline()Out[31]: 'testwww\\n'\r\nreadlines() 将所有行内容读到一个 list 里面 , 会将换行符读取进来\r\nIn [24]: f = open('/tmp/test.txt','r')\r\nIn [25]: f.readlines()\r\nOut[25]: ['test\\n', 'test\\n', 'test\\n', 'testwww\\n', 'tadc\\n']\r\nwrite 写入内容到文件 , f.write('hello')\r\nwritelines 将一个序列写入到文件中,但不会加换行符\r\nIn [32]: f = open('/tmp/test.txt','w')\r\nIn [33]: f.writelines(['11111','hello world','33444'])\r\nIn [34]: f.close()\r\n[root@yeahmonitor ~]# cat /tmp/test.txt\r\n11111hello world33444[root@yeahmonitor ~]#\r\ntruncate 清空文件,f.truncate() , 但是以 a 方式打开,则不会清空,因为 a 的方式是定位到文件末尾,该函数是从文件指针当前的位置开始清空内容的。\r\nflush 函数,将缓冲区的内容写入到硬盘中 , close() 函数会在关闭文件之前执行此操作。\r\nseek ,seek(offset[,whence]) ,offset 表示移动多少字节, whence 为 1 的时候表示相对于当前位置移动的;当 2 的时候从文件的末尾往后移动,但不一定所有\r\n的平台都支持;默认为 0 表示从文件开头往后移动\r\ntell() 返回当前文件指针的偏移量:\r\nIn [35]: f = open('/tmp/test.txt')# 默认以 r 方式打开\r\nIn [36]: f.tell()# 以 r 方式打开文件,定位到文件末尾\r\nOut[36]: 0\r\nIn [40]: f.seek(3)\r\nIn [41]:\r\nOut[41]:\r\nIn [42]:\r\nOut[42]:\r\nIn [43]:\r\nOut[43]:\r\nf.tell()\r\n3\r\nf.read()\r\n'11hello world33444'\r\nf.tell()\r\n21\r\nIn [44]: f.seek(0)# 回到文件开头\r\nIn [45]: f.tell()\r\nOut[45]: 0\r\nIn [46]: f.read()\r\nOut[46]: '11111hello world33444'\r\nclose() 函数,关闭当前打开的文件\r\nfileno() 函数,返回当前的文件描述符,一个数字\r\nisatty() 函数,当前打开的文件是否是一个终端设备\r\nclosed 属性,当前文件是否关闭 ,|True,False, f.closed\r\nfile 对象是一个迭代器:\r\nnext() 方法 , 一行一行的读 , 每次读取一行\r\nIn [48]: f = open('/tmp/test.txt')\r\nIn [49]: f.next()\r\nOut[49]: '11111hello world33444'\r\nIn [50]: f.next()\r\n---------------------------------------------------------------------------\r\nStopIteration\r\nTraceback (most recent call last)\r\n<ipython-input-50-c3e65e5362fb> in <module>()\r\n----> 1 f.next()\r\nStopIteration:\r\nwith 语法\r\n一般情况打开一个文件,经过操作之后,都要显式的执行xx.close() 将文件关闭 .with 用于需要打开、关闭成对的操作,可以自动关闭打开对象 .\r\nwith expression as obj:# 将打开的对象赋值给 obj\r\nexpression\r\n#obj 的作用域只在 with 语句中\r\n示例:\r\nIn [55]: with open('/tmp/test.txt') as f:\r\n....:\r\nfor line in f:\r\n....:\r\nprint(line)\r\n....:\r\n11111hello world33444tadc\r\ntadc\r\nwith 语法是可以自定义的,在面向对象中会更加详细的讲解。\r\n文本处理\r\n字符串处理\r\n分隔和连接\r\nsplit 函数,默认以空格分隔,可以传参指定分隔符\r\nIn [1]: a = \"aaa hello world\"\r\nIn [2]: a.split()\r\nOut[2]: ['aaa', 'hello', 'world']\r\nIn [3]: a = \"aaa,hello,world\"\r\nIn [4]: a.split(',')\r\nOut[4]: ['aaa', 'hello', 'world']\r\nIn [5]: a.split(',',1)# 指定第二个可选参数,指定最大分隔\r\nOut[5]: ['aaa', 'hello,world']\r\njoin 函数,字符串的连接 , 用于连接一个迭代器,返回一个字符串\r\nIn [6]: it = [\"hello\",\"beijing\",\"and xi'an\"]\r\nIn [7]: \",\".join(it) # 以逗号连接列表为一个字符串\r\nOut[7]: \"hello,beijing,and xi'an\"\r\n+ 也可以连接字符串 , 由于字符串是不可变的,所以在使用加号连接两个字符串的时候需要创建新的新的内存用来存储数据。\r\n字符串格式化\r\npython 中字符串格式化主要有两种方式 .\r\n占位符,%s 字符串,%d 整数 , %f 浮点数\r\nIn [8]: \"hello %s\" % \"world\"\r\nOut[8]: 'hello world'\r\nIn [9]: \"hello %s %s\" % (\"world\",\" and xi'an\")\r\nOut[9]: \"hello world and xi'an\"\r\n字符串查找\r\nfind 函数,返回子字符串在原字符串中第一次出现的位置 , 若没有找到则返回 -1\r\nIn [12]: str = \"this is a dog\"\r\nIn [13]: str.find(\"is\")\r\nOut[13]: 2\r\nIn [14]: str.find(\"is\",2,4)\r\nOut[14]: 2\r\nIn [15]: str.find(\"is\",3,4)# 还可以接受两个可选参数, start,end 用于标示查找的起始位置和结束位置\r\nOut[15]: -1字符串替换\r\nreplace 函数,用于替换\r\nIn [16]: str\r\nOut[16]: 'this is a dog'\r\nIn [17]: str.replace(\"is\",\"are\")\r\nOut[17]: 'thare are a dog\r\nstrip 函数,用来将字符串首尾的空白 ( 空格,制表符 ,\\r,\\n,\\t) 移除\r\nIn [18]: s = \"hello world \"\r\nIn [19]: s\r\nOut[19]: 'hello world '\r\nIn [20]: s.strip()\r\nOut[20]: 'hello world'\r\nIn [21]: s = \"hello world\\n\"\r\nIn [22]: s\r\nOut[22]: 'hello world\\n'\r\nIn [23]: s.strip()\r\nOut[23]: 'hello world'\r\nrstrip 移除右边的空白,lstrip 移除左边的空白\r\n正则表达式\r\npython 中的正则标示是以标准库的形式提供的 , 在使用之前要先导入 import re\r\n正则表达式的基本模式:\r\n字面模式: 就是字面长量,就代表其本身\r\n. 匹配任何字符\r\n\\w 匹配一个单词(字母) \\W 匹配非字母\r\n\\s 匹配空白 \\S 匹配非空白字符\r\n\\d 匹配数字\r\n^ 开头 $ 结尾\r\n\\ 转义字符\r\n次数的匹配 , 匹配其前面的字符出现的次数 :\r\n* 0 次或多次\r\n+ 一次或多次\r\n? 零次或一次\r\n{n} 出现 n 次\r\n{m,n} 出现 m 到 n 次\r\n中括号 , 表示一个范围 :\r\n中括号用于指向一个字符集合\r\n中括号可以使用元字符\r\n中括号中的. 表示其字面意思\r\n如[a-z] .\r\n捕获:\r\n位置捕获 (...)\r\n- 命名捕获 (?P...)\r\nIn [25]: import re\r\nIn [26]: s = \"this is test for re walter.liu@163.com test\"\r\nIn [27]: m = re.search(r'[\\w.-]+@[\\w.-]+',s)#r 表示字符串中的所有字符都不会被转义\r\nIn [28]: m\r\nOut[28]: <_sre.SRE_Match at 0x2156bf8>\r\nIn [29]: m.group()Out[29]: 'walter.liu@163.com'\r\nIn [30]: m = re.search(r'([\\w.-]+)@[\\w.-]+',s)# 小括号表示位置捕获\r\nIn [31]: m.groups()\r\nOut[31]: ('walter.liu',)\r\nIn [32]: m = re.search(r'(?P<user>[\\w.-]+)@[\\w.-]+',s)# 将捕获 ( 小括号中匹配的内容 ) 到的字符赋值给 user 变量\r\nIn [33]: m.groupdict()\r\nOut[33]: {'user': 'walter.liu'}\r\n正则表达式中的断言 ( 作为选学 ) :\r\n在目标字符串当前匹配位置的前面或后面进行的一次测试,但不占用字符\r\n前向断言: (?=...) 肯定 ;(?!...) 否定\r\n后向断言: (?<=...) 肯定 ;(?<!...) 否定\r\n前面出现任何字符,以字符e 结尾的字符 :\r\nIn [48]: m = re.findall(r'\\w+(?=e)',s)\r\nIn [49]: m\r\nOut[49]: ['t', 'r', 'walt', 't']\r\nIn [50]: s\r\nOut[50]: 'this is test for re walter.liu@163.com test'\r\n前面紧跟@ 的字符串 :\r\nIn [59]: m = re.findall(r'(?<=@)\\w+',s)\r\nIn [60]: m\r\nOut[60]: ['163']\r\nIn [61]: m = re.search(r'(?<=@)\\w+',s)\r\nIn [62]: m\r\nOut[62]: <_sre.SRE_Match at 0x235a850>\r\nIn [63]: m.group()\r\nOut[63]: '163'\r\n下边具体说下re 模块的相关方法:\r\nre.match(p,text) :p 为正则表达式模式, text 要查找的字符串,会返回一个 match 对象\r\nre.search(p,text) : 只要在 text 中匹配到了 p 就返回,只返回第一个匹配到的\r\nre.findall(p,text) :将能匹配上的全返回,会返回一个 list\r\nre.split(p,text) : 按照 p 匹配,并且以匹配到的字符为分隔符切割 text, 返回一个切割后的 list\r\nre.sub(p,s,text) : 替换,将 p 匹配到的字符替换为 s.\r\npattern = re.compile(p) 先编译 p 模式,当正则表达式模式比较复杂的时候,会先编译,然后再使用result = patter.match(text) , 这就可以使用编译好的\r\n模式去匹配各种字符串了。性能会有所提升。\r\n示例:\r\nIn [1]: import re\r\nIn [2]: text = \"c++ python3 python3 perl ruby lua java php\"\r\n#match\r\nIn [4]: re.match(r'c\\+\\+',text)#+ 要转义\r\nOut[4]: <_sre.SRE_Match at 0x2be66b0>\r\nIn [5]: a = re.match(r'c\\+\\+',text)# 将返回的 match 对象赋值给一个变量\r\nIn [6]: a.group()# 使用 group 方法查看匹配到的内容\r\nOut[6]: 'c++'\r\n#match 从头匹配\r\nIn [15]: a = re.match(r'java',text)# 因为 java 不在这行字符串的开头,所以 match 返回为 none.\r\nIn [16]: a\r\n#search, 不需要从头匹配,只要能匹配到就返回\r\nIn [19]: a = re.search(r'java',text)\r\nIn [20]: aOut[20]: <_sre.SRE_Match at 0x2466bf8>\r\nIn [21]: a.group()\r\nOut[21]: 'java'\r\n#findall 返回所有匹配到的内容,返回一个列表\r\nIn [22]: text\r\nOut[22]: 'c++ python3 python3 perl ruby lua java php'\r\nIn [23]: re.findall(r'python',text)\r\nOut[23]: ['python', 'python']\r\nIn [24]: li = re.findall(r'python',text)\r\nIn [25]: li\r\nOut[25]: ['python', 'python']\r\n#split\r\nIn [27]: li = re.split(r' perl',text)\r\nIn [28]: li\r\nOut[28]: ['c++ python3 python3', ' ruby lua java php']\r\n#sub\r\nIn [29]: re.sub(r'ruby','php5',text)\r\nOut[29]: 'c++ python3 python3 perl php5 lua java php'\r\n元字符的使用:\r\nIn [30]: re.findall(r'p+',text)# 匹配一个或多个字符 p\r\nOut[30]: ['p', 'p', 'p', 'p', 'p']\r\nIn [31]: re.findall(r'p[a-zA-Z]+',text)#p 后面跟一个或多个字母\r\nOut[31]: ['python', 'python', 'perl', 'php']\r\nIn [32]: re.findall(r'c[a-zA-Z]*',text)#* 匹配前面的字符出现 0 次或多次\r\nOut[32]: ['c']\r\nIn [34]: re.findall(r'c[^a-zA-Z]*',text)#^ 用在中括号中意思是取反,本例中是 c 后面跟 0 个或多个非字母的字符\r\nOut[34]: ['c++ ']\r\nIn [35]: re.findall(r'c[a-zA-Z]?',text)#? 表示前面的字符出现 0 次或 1 次\r\nOut[35]: ['c']\r\nIn [36]: re.findall(r'[pj][a-zA-z]+',text)\r\nOut[36]: ['python', 'python', 'perl', 'java', 'php']\r\nIn [37]: re.findall(r'p[^0-9]+|j[a-zA-Z]+',text)\r\nOut[37]: ['python', 'python', 'perl ruby lua java php']\r\n#^ 匹配开头\r\nIn [38]: re.findall(r'^c..',text)\r\nOut[38]: ['c++']\r\nIn [41]: re.findall(r'p\\w+',text)#\\w 还可以匹配到数字\r\nOut[41]: ['python3', 'python3', 'perl', 'php']\r\nIn [42]: re.findall(r'p\\w+\\d',text)\r\nOut[42]: ['python3', 'python3']\r\nIn [44]: re.findall(r'p\\w{5,9}',text)\r\nOut[44]: ['python3', 'python3']\r\n#*? 非贪婪模式 ,+? 非贪婪模式\r\nIn [52]: re.findall(r'p[^0-9]*',text)# 贪婪\r\nOut[52]: ['python', 'python', 'perl ruby lua java php']\r\nIn [53]: re.findall(r'p[^0-9]*?',text)# 非贪婪\r\nOut[53]: ['p', 'p', 'p', 'p', 'p']\r\nIn [54]: re.findall(r'p[^0-9]+?',text)# 非贪婪\r\nOut[54]: ['py', 'py', 'pe', 'ph']\r\nIn [55]: re.findall(r'p[^0-9]+',text)# 贪婪\r\nOut[55]: ['python', 'python', 'perl ruby lua java php']\r\n#() 分组, (?<name>pattern) 命名分组\r\nIn [65]: a = re.findall(r'(p[a-zA-z]+)([0-9])',text)In [66]: type(a)\r\nOut[66]: list\r\nIn [67]: a[1]\r\nOut[67]: ('python', '3')\r\nIn [68]: a[1][0]\r\nOut[68]: 'python'\r\nIn [69]: a\r\nOut[69]: [('python', '3'), ('python', '3')]\r\nIn [75]: a = re.search(r'(?P<name>p[a-zA-Z]+)(?P<version>[0-9])',text)\r\nIn [76]: type(a)\r\nOut[76]: _sre.SRE_Match\r\nIn [77]: a.group\r\na.group\r\na.groupdict\r\na.groups\r\nIn [77]: a.groupdict()\r\nOut[77]: {'name': 'python', 'version': '3'}\r\nIn [78]: a.group()\r\nOut[78]: 'python3'\r\nIn [79]: a.group('name')\r\nOut[79]: 'python'\r\n#compile\r\nIn [80]: p = re.compile(r'(?P<name>p[a-zA-Z]+)(?P<version>[0-9])')# 先编译\r\nIn [81]: r = p.search(\"python3\")\r\nIn [82]: r.groupdict()\r\nOut[82]: {'name': 'python', 'version': '3'}\r\n一篇很全面讲解 python 正则表达式的文章 :http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html\r\n案例分析\r\n有多个日志文件,统计访问前十的 IP 地址和访问次数。\r\n面向对象基础\r\n在了解面向对象之前,先了解下编程范式:\r\n编程范式是一类典型的编程风格,是一种方法学\r\n编程范式决定了程序员对程序执行的看法\r\nOOP 中,程序是一系列对象的相互作用\r\npython 支持多种编程范式:面向过程,面向对象,面向切面 ( 装饰器部分 ) 等\r\nOOP 思想\r\n面向对象的基本哲学:世界由具有各自运动规律和内部状态的对象组成,对象之间的相互作用和通讯构成了世界\r\n唯一性,世界上没有两片相同的树叶 , 同样的没有两个相同的对象\r\n分类性,分类是对现实世界的抽象\r\n三大特性,继承、多态和封装\r\n再来复习下类型 :\r\n计算机是用来处理数据的\r\n数据是一段内存\r\n类型告诉计算机这段内存是如何组织\r\n通过对基本类型的组织,可以构造更复杂的类型(如 list,set 等)\r\nIn [1]: li = [2,3,4,5]# 列表中的每个元素都是整数,整数是一个基本类型,列表是由基本类型组织成的一个复杂的数据类型\r\nIn [2]: f = lambda x:sum(x)/len(x)\r\nIn [3]: f(li)\r\nOut[3]: 3\r\n另一个组织数据的示例:\r\n假如有一个表示门的数据\r\n门有两个属性:门牌号和打开 / 关闭状态有两个操作,打开和关闭\r\n#!/usr/bin/env python\r\n# 定义两个门的数据,用列表表示。第一个元素表示门的编号,\r\n# 第二个元素表示门的状态\r\ndoor1 = [1,'closed']\r\ndoor2 = [2,'closed']\r\n# 定义两个函数,表示可以对门执行的操作:打开、关闭\r\ndef openDoor(door):\r\ndoor[1] = 'open'\r\ndef closeDoor(door):\r\ndoor[1] = 'closed'\r\nopenDoor(door1)\r\nprint door1\r\ncloseDoor(door1)\r\nprint door1\r\n# 以上组织数据的方式有一个弊端,就是假如我们把列表的两个元素换下位置,那么我们对门的操作(打开或关闭)是无法完成的。也就是说作为门这个对象的使用者需要了解里面数据具体的布局。\r\n用类来组织数据\r\n#!/usr/bin/env python\r\n# 使用 class 关键字声明一个门的类\r\nclass Door(object):\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\n# 定义对门的打开操作 , 作用域在该类里面\r\nself.status = 'open'\r\ndef close(self):\r\n# 定义对门的关闭操作,作用域在类里面\r\nself.status = 'closed'\r\ndoor = Door(1,'closed')# 实例化一个门的示例,编号为 1 的门\r\ndoor.open()# 对编号为 1 的门执行打开操作\r\nprint door.num,door.status# 输出门 1 的相关属性\r\ndoor.close()# 执行关闭操作\r\nprint door.num,door.status\r\nprint type(door)\r\n# 关于类的具体定义下边会详解\r\n类与实例\r\n类 是一类实例的抽象,抽象的属性和操作,如 Door 类\r\n实例 是类的具体化 , door = Door(1,'status') ,实例化 door 就是一个具体的对象了。\r\n定义类\r\nclass Name:\r\n这种方式在 python3 和 python2.3 之前比较流行,但是在 python2.4 之后所有类都要继承自object 类。\r\nclass Name(parents):\r\n示例:\r\n#!/usr/bin/env python\r\n#object 是所有类的父类,定义了一些通用的操作\r\nclass Door(object):\r\n# 类里面的操作称之为方法,\r\ndef __init__(self,num,status):\r\nself.num = numself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndoor = Door(1,'closed')\r\ndoor.open()\r\nprint door.num,door.status\r\ndoor.close()\r\nprint door.num,door.status\r\nprint type(door)\r\n定义方法:\r\nclass Name(parents):\r\ndef method(self,args...):\r\n# 定义一个方法,第一个参数都是\r\n#self, 表示实例本身 . 调用方法的时候是不需要传递\r\n#self 这个参数的 , 解释器会自动的将当前的实例传递\r\n# 给 self\r\nbody\r\n关于self :\r\ndoor = Door(1,'open')#self 代表的就是 door 这个实例本身\r\ndoor2 = Door(2,'closed')\r\n构造方法:\r\nclass Name(parents):\r\ndef __init__(self,args...):\r\nexpression\r\ninstance = Name(args...)\r\n__init__ 就是 python 类中的构造方法 . 实例化类的时候就会调用构造方法door = Door(1,'open') 传递的参数就是构造方法所需要的参数 .\r\nself 关键字 :\r\nself 代表实例本身\r\n实例变量\r\nclass Door(object):\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\nself.num 就是一个实例变量(也可称为属性),实例变量一般都在构造函数中定义,但也可以在类的其他方法里面定义(但要尽可能在再构造函数中定义实\r\n例变量)。实例变量是依附于某一个具体的实例的。定义语法为self.argName 。\r\n实例方法 刚才 Door 类中定义的方法都称为实例方法(一般简称为方法)。实例方法也是可以动态修改的:\r\n#!/usr/bin/env python\r\nclass Door(object):\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'def close(self):\r\nself.status = 'closed'\r\ndoor = Door(1,'closed')\r\ndef test():\r\nprint \"test\"\r\ndoor.test = test\r\n# 动态的给 door 实例增加一个 test 属性,该属性的值为 test 函数,该属性只对当前实例 (door) 有效。\r\ndoor.test()\r\n接下来介绍下,类的封装性\r\n私有成员\r\n以双下划线开始,不以双下划线结束\r\npython 中其实没有真正的私有成员\r\n#!/usr/bin/env python\r\nclass Door(object):\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndef __test(self):# 定义了一个私有方法\r\nprint \"__test\"\r\ndoor = Door(1,'closed')\r\n#door.__test()# 这一行会报错\r\ndoor._Door__test()# 这一行是可以正常打印的,所以 python 中没有真正的私有成员,但是在生产上不要使用这种方式调用私有成员。\r\n类变量\r\n定义在实例方法之外的变量\r\n所有实例共享类变量 , 但某一个实例对类变量的修改不会影响其他实例和类本身\r\n类变量可以直接访问\r\n#!/usr/bin/env python\r\nclass Door(object):\r\na = 1# 定义一个类变量\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndef __test(self):\r\nprint \"__test\"\r\ndoor1 = Door(1,'closed')\r\ndoor2 = Door(2,'open')\r\nprint Door.a# 可以直接使用类访问类变量\r\nprint door1.a# 通过实例访问类变量\r\nprint door2.a\r\n# 以上三行输出的值是一样的\r\n示例二:\r\n#!/usr/bin/env python\r\nclass Door(object):\r\na = 1def __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndef __test(self):\r\nprint \"__test\"\r\ndoor1 = Door(1,'closed')\r\ndoor2 = Door(2,'open')\r\nprint Door.a\r\nprint door1.a\r\ndoor1.a = 100\r\nprint door2.a\r\nprint Door.a\r\nprint door1.a\r\n[root@liuzhenwei ~]# python d2.py\r\n1\r\n1\r\n1\r\n1\r\n100\r\n类方法\r\n使用@classmethod 装饰器装饰的方法\r\n第一个参数代表类本身\r\n类方法可以直接调用\r\n类方法里可以定义类变量\r\n示例:\r\n#!/usr/bin/env python\r\nclass Door(object):\r\na = 1\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndef __test(self):\r\nprint \"__test\"\r\n# 定义一个类方法\r\n@classmethod\r\ndef test(cls):\r\ncls.b = 200# 定义一个类变量\r\nprint \"test class func\"\r\nDoor.test()# 直接使用类调用类方法\r\nprint Door.b # 打印类变量\r\nd1 = Door(1,'open')\r\nd1.test()# 通过实例调用类方法\r\n# 在类方法里不能调用实例相关的东西,即不能使用 self\r\n静态方法\r\n静态方法以@staticmethod 装饰器装饰\r\n静态方法也可以直接调用\r\n静态方法没有限定第一个参数\r\n示例:\r\n#!/usr/bin/env pythonclass Door(object):\r\na = 1\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndef __test(self):\r\nprint \"__test\"\r\n@classmethod\r\ndef test(cls):\r\ncls.b = 200\r\nprint \"test class func\"\r\n# 定义一个静态方法\r\n@staticmethod\r\ndef test2():\r\nprint \"test2 static func\"\r\nDoor.test2()# 通过类调用静态方法\r\nd1 = Door(1,'open')\r\nd1.test2()# 通过实例调用静态方法\r\n属性\r\n属性以@property 装饰器装饰\r\n属性的setter 方法\r\n属性的适用场合\r\n属性是属于实例的。\r\n示例:\r\n#!/usr/bin/env python\r\nclass Door(object):\r\na = 1\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\ndef __test(self):\r\nprint \"__test\"\r\n@classmethod\r\ndef test(cls):\r\ncls.b = 200\r\nprint \"test class func\"\r\n@staticmethod\r\ndef test2():\r\nprint \"test2 static func\"\r\n# 定义一个属性, @property 装饰器可以使被装饰\r\n# 的方法称为一个属性 , 类似于其他语言的 get 方法\r\n@property\r\ndef opened(self):\r\nreturn self.status == 'open'\r\n# 当一个方法被 @peoperty 装饰之后,自己\r\n# 也就称为另一个装饰器\r\n@opened.setter\r\ndef opened(self,value):\r\n# 此 opened 就类似于其他语言的 set 方法# 该方法必须与上一个方法同名\r\nif value:\r\nself.status = 'open'\r\nelse:\r\nself.status = 'closed'\r\nd1 = Door(1,'open')\r\nprint d1.opened # 实例调用属性\r\nd1.opened = False\r\n# 给该属性赋值,相当于调用了该属性的 set 方法进行赋值操作\r\nprint d1.opened\r\n# 调用属性,也就是相当于调用了 get 方法\r\n为什么要这么麻烦的使用这个呢??\r\n下边是一个简单的时间类,默认以字符串的形式返回当前的时间,也可以以字符串的形式设置时间,整体来说是封装了私有属性__time :\r\n#!/usr/bin/env python\r\nimport datetime\r\nclass T(object):\r\ndef __init__(self):\r\nself.__time = datetime.datetime.now()\r\n@property\r\ndef time(self):\r\nreturn self.__time.strftime('%Y-%m-%d %H:%M:%S')\r\n@time.setter\r\ndef time(self,value):\r\nself.__time = datetime.datetime.strptime(value,'%Y-%m-%d %H:%M:%S')\r\nt = T()\r\nprint t.time\r\nt.time = '2015-12-20 15:30:00'\r\nprint t.time\r\n在工作中,有些需求需要对 IP 地址进行处理,因为在计算机中 IP 都是整数的形式做运算的,但是展现出来的时候都是字符串形式(点分十进制),便于人类\r\n查看。就可以使用上述方法实现对 IP 操作的封装。\r\n以上就是 python 中关于类的基本定义与操作。下边再介绍一些类的更高级的操作。\r\n魔术方法\r\n魔术方法总是由双下划线包围,如__init__ ,这些方法都是有特殊用途的\r\n__new__ , __init__ , __del__\r\n__cmp__ , __eq__ , __ne__ , __lt__ , __le__ , __gt__ , __ge__\r\n__add__ , __sub__ , __mul__ , __div__\r\n__str__ , __repr__ , __unicode__\r\n__new__ 方法,会在元类里面讲解到,这里暂时不做讨论。\r\n__del__ 方法,简单理解为是一个析构函数,当一个对象被垃圾回收机制回收的时候,其实就是调用了该方法,可以在该方法中定义一些释放资源的操作,\r\n如文件的关闭、数据库连接的关闭等。\r\n__cmp__ 方法,是一个通用的比较函数。在 python3 中该方法发生了较大的变化。一般工作中不会使用该方法,而是分别使用__eq__ , __ne__ 等之类的方法。\r\n__eq__ 方法,定义了一个等于的行为,重载了等于操作符 :\r\n#!/usr/bin/env python\r\nclass T(object):\r\ndef __init__(self,a):\r\nself.a = a\r\ndef __eq__(self,other):\r\nreturn self.a == other.a\r\nt1 = T(100)t2 = T(100)\r\nprint t1 == t2 # 调用了 __eq__ 方法\r\nprint t2 == t1\r\n__add__ 方法:\r\n#!/usr/bin/env python\r\nclass A(object):\r\ndef __init__(self,a):\r\nself.a = a\r\ndef __add__(self,other):\r\nreturn A(self.a + other.a)\r\na1 = A(200)\r\na2 = A(500)\r\na3 = a1 + a2\r\nprint a3.a # 输出 700\r\n# 其实, str 对象也是定义了一个 __add__ 方法,重载了加号为字符串连接\r\n__str__ 方法,定义了我们使用 str 方法活直接 print 对象时候的一个行为:\r\n#!/usr/bin/env python\r\nclass S(object):\r\ndef __init__(self,a):\r\nself.a = a\r\ndef __str__(self):\r\nreturn \"a=%s\" % self.a\r\na = S('hello')\r\nprint str(a)# 输出 a=hello\r\n__repr__ 类似于__str__ , 不过__repr__ 返回的是机器可读的字符串,__str__ 返回的是人类可读的 .\r\n__unicode__ 返回一个 unicode 的对象u'hello' ,类似于__str__ 方法。\r\n__hash__ 方法 :\r\nIn [4]: class A(object):\r\ndef __hash__(self):\r\nreturn 123\r\n...:\r\nIn [5]: a = A()\r\nIn [6]: hash(a)\r\nOut[6]: 123\r\n# 我们定义类的时候是不需要定义 __hash__ 方法 的,因为父类 object 已经定义过了。\r\n__getattr__ 方法 , 当一个实例有这个属性的时候直接返回,如果没有会调用该方法。\r\n#!/usr/bin/env python\r\nclass Test(object):\r\ndef __init__(self):\r\nself.a = 1\r\ndef foo(self):\r\nprint \"call foo\"\r\ndef __getattr__(self,name):\r\nprint \"get attr %s\" % name\r\nreturn name\r\nt = Test()\r\nprint t.a\r\nt.foo()\r\nprint t.bar# 没这个方法,也没这个属性,所以会调用 __getattr__ 方法\r\n__enter__ 和__exit__ , 在 IO 的部分说过 with 语法,只要一个类实现了这个两个方法就可以使用 with 语法:\r\nclass W(object):\r\ndef __init__(self):\r\nself.f = open('/tmp/test.txt','w')\r\ndef __enter__(self):\r\nreturn self.f\r\ndef __exit__(self,*excinfo):\r\n# 该方法接受一个可变参数,出现异常的时候将异常传\r\n# 值给该参数,在该函数内根据异常可以做相应的处理\r\nself.f.close()\r\nwith W() as f:\r\nf.write(\"hello world\") # 向文件中写一行内容\r\n面向对象进阶\r\n继承\r\n在面向对象,继承是一个很重要特性。\r\n子类与父类: 子类是对父类的一种扩展,在父类的属性和方法上进行一些扩展\r\n示例:\r\n#!/usr/bin/env python\r\n# 定义一个带编号和状态的门类\r\nclass Door(object):\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\n# 定义一个可以锁的门的类\r\nclass Lockable(object):\r\ndef __init__(self,num,status,locked):\r\nself.num = num\r\nself.status = status\r\nself.locked = locked\r\ndef open(self):\r\nif not self.locked:\r\nself.status = 'open'\r\nelse:\r\nprint \"the door is locked\"\r\ndef close(self):\r\nself.close = 'closed'\r\n上述两个类,其实有很多是相同的东西,只是在Lockable 类中新增某些新的门的特性而已。\r\n使用子类继承父类:\r\n# 继承自父类 Door\r\nclass Lockable(Door):\r\ndef __init__(self,num,status,locked):\r\nsuper(Lockable,self).__init__(num,status)# 调用父类的构造函数\r\nself.locked = locked\r\n# 对 open 方法进行重载\r\ndef open(self):\r\nif not self.locked:\r\n# 调用父类的方法\r\nsuper(Lockable,self).open()\r\nelse:\r\nprint \"the door is locked\"重写:\r\n上边的示例中,针对于open 方法就是进行了重写。子类中的方法与父类的方法名相同,其实构造函数也进行了重写,扩展了一些功能。\r\n上边例子中我只是为了扩展一点内容而已,不是真的需要完全重写父类的方法,所以在子类的同名方法中,我们就需要调用父类的方法:\r\n使用super(className,self) 来调用父类的同名方法 , 这样就构造了一个 super 对象,代表的是当前类的父类。\r\n示例:\r\n#!/usr/bin/env python\r\nclass Door(object):\r\ndef __init__(self,num,status):\r\nself.num = num\r\nself.status = status\r\ndef open(self):\r\nself.status = 'open'\r\ndef close(self):\r\nself.status = 'closed'\r\nclass Lockable(Door):\r\ndef __init__(self,num,status,locked):\r\nsuper(Lockable,self).__init__(num,status)\r\nself.locked = locked\r\ndef open(self):\r\nif not self.locked:\r\nsuper(Lockable,self).open()\r\nelse:\r\nprint \"the door is locked\"\r\nld = Lockable(1,'closed',True)\r\nld.open()\r\n# 输出 the door is locked\r\n还可以对子类增加一个locke 的方法:\r\nclass Lockable(Door):\r\ndef __init__(self,num,status,locked):\r\nsuper(Lockable,self).__init__(num,status)\r\nself.locked = locked\r\ndef open(self):\r\nif not self.locked:\r\nsuper(Lockable,self).open()\r\nelse:\r\nprint \"the door is locked\"\r\ndef lock(self):\r\nself.locked = True\r\n多继承\r\n大多数情况只会用到单继承,但是 python 也是提供多继承的支持的。\r\n多继承语法 :\r\nclass ClassName(p1,p2,...):\r\n示例:\r\n#!/usr/bin/env python\r\nclass A(object):\r\n# 若一个类没有定义构造方法, python 解释器默认会生成一个这样的构造方法\r\ndef __init__(self):\r\npass\r\ndef ma(self):\r\nprint \"A.method.a\"\r\nclass B(object):\r\n# 该类没那个定义 __init__ 方法,默认会自动生成\r\ndef mb(self):print \"B.method.b\"\r\nclass C(A,B):\r\npass\r\nc = C()\r\n# 虽然在 C 类里什么都没做,但它已经从 A , B 里面继承了两个方法\r\nc.ma()\r\nc.mb()\r\n但是多继承中会存在某些问题,加入 C 的两个父类的某个方法名称是一样的。那么子类会选择第一个父类的方法执行。\r\n#!/usr/bin/env python\r\nclass A(object):\r\ndef __init__(self):\r\npass\r\ndef m(self):\r\nprint \"A.method.a\"\r\nclass B(object):\r\ndef m(self):\r\nprint \"B.method.b\"\r\nclass C(A,B):\r\npass\r\nc = C()\r\nc.m()# 输出 A.method.a\r\n目前来看就是子类就是执行的其父类列表里左边的父类的方法。那么看下边的示例:\r\n#!/usr/bin/env python\r\nclass A(object):\r\ndef __init__(self):\r\npass\r\ndef m(self):\r\nprint \"A.method.a\"\r\nclass B(A):\r\ndef m(self):\r\nprint \"B.method.b\"\r\nclass C(A,B):\r\npass\r\nc = C()\r\nc.m()\r\n# 执行上述代码后会抛出一个错误:\r\n[root@liuzhenwei ~]# python cl.py\r\nTraceback (most recent call last):\r\nFile \"cl.py\", line 15, in <module>\r\nclass C(A,B):\r\nTypeError: Error when calling the metaclass bases\r\nCannot create a consistent method resolution\r\norder (MRO) for bases A, B\r\nMRO: 方法确定的一个顺序,在 python 中存在多继承,当继承列表中有同名方法的时候, python 就是根据这个 MRO 来选择子类该执行哪个方法的。\r\n包管理\r\n如何使用包:\r\nimport\r\nfrom ...import ...\r\nfrom ...import ... as ...\r\nimport sys 此时就可以使用 sys 包了\r\nfrom os import path 引用 os 包下面的 path 包from os import path as p 将引用进来的 path 包做了个别名为 p\r\n创建自己的模块 :\r\n单文件模块:\r\n每个 python 文件都是一个模块\r\n文件名就是模块名\r\n注:包名尽量要全是小写\r\n示例:\r\n[root@liuzhenwei t]# vim mod1.py# 创建一个空的 python 文件\r\n# 在 ipython 下直接 import 即可\r\nIn [1]: import mod1\r\nIn [2]: help(mod1)\r\n目录模块 :\r\ninit.py 要想使目录称为一个模块,该目录下必须包含这个文件\r\n子模块 , 在这个目录下其他所有文件都称为一个子模块\r\nall 属性 , 在 init.py 中可以没有任何内容,但也可以有 all 属性\r\n示例:\r\n[root@liuzhenwei t]# ls foo/\r\nbar.py\r\n__init__.py\r\n# 这个时候就可以使用下属方引入 bar 子模块\r\nfrom foo import bar\r\n或\r\nimport foo.bar\r\n#__all__ 属性\r\n[root@liuzhenwei t]# cat foo/__init__.py\r\n__all__ = ['bar',]# 保存当前目录下所有子模块的列表\r\nIn [1]: from foo import *# 会将 __all__ 属性中列表的锁有子模块导入进来\r\nIn [2]: bar\r\nOut[2]: <module 'foo.bar' from 'foo/bar.pyc'>\r\n如果这个目录下还有一个子目录的话,那么子目录也必须得有 init.py 这个文件。\r\n示例:\r\n[root@liuzhenwei t]# ls foo/\r\nbar.py bar.pyc __init__.py __init__.pyc\r\n[root@liuzhenwei t]# cat foo/bar.py\r\ndef func():\r\nprint \"test mod\"\r\n[root@liuzhenwei t]# cat test.py\r\n#!/usr/bin/env python\r\nfrom foo import bar\r\nbar.func()\r\n注: import 即执行,即在 import 某个文件模块的时候,是会执行这个 python 文件的,如:\r\n[root@liuzhenwei t]# cat foo/bar.py\r\ndef func():\r\nprint \"test mod\"\r\nprint 11# 这有一行输出语句,在执行 import 导入该模块的时候会被执行\r\nIn [1]: from foo import bar\r\n11\r\n解决方法:if __name__ == '__main__' :\r\n[root@liuzhenwei t]# cat foo/bar.py\r\ndef func():\r\nprint \"test mod\"if __name__ == '__main__':\r\n# 在被其他文件作为模块引入的时候,\r\n# 该条件判断为 false, 所以下边的语句被不会执行,\r\n# 但是可以单独手动的执行该文件, python bar.py 。\r\nprint 11\r\n模块的查找和引用\r\nsys 模块下有一个path 属性,保存了 Python 默认的查找路径,按照顺序依次往后查找所引用的包:\r\n>>> import sys\r\n>>> sys.path\r\n['', '/usr/lib64/python26.zip', '/usr/lib64/python2.6', '/usr/lib64/python2.6/plat-linux2', '/usr/lib64/python2.6/lib-tk', '/usr/lib64/python2.6/lib-old', '/us\r\n# 列表的第一个值为空,表示当前目录,当使用 import 导入模块的时候,默认会先查找当前目录下是否有该模块,然后依次查找后边给出的路径。\r\n在工作中,有时候也会见到有些同事或者其他朋友写程序的时候,将一个特定的查找路径追加到sys.path 中,方便程序导入模块。但一般不建议这么做,尽\r\n量少修改系统原有的 “ 环境变量 ” 等信息。\r\n简单了解一个模块:\r\nOS 模块\r\n为访问操作系统的特定熟悉提供方法\r\n提供了对平台模块的封装(对 windows, 对 mac 的封装等)\r\n对环境变量的操作:可以修改或者获取环境变量,修改环境变量是持久性修改的。\r\n>>> import os\r\n>>> os.environ\r\n{'SSH_ASKPASS': '/usr/libexec/openssh/gnome-ssh-askpass', 'LESSOPEN': '||/usr/bin/lesspipe.sh %s', 'SSH_CLIENT': '10.25.0.1 49909 22', 'SELINUX_USE_CURRENT_RAN\r\n工作目录的相关操作:os.getcwd() 获取当前的工作目录\r\n文件系统相关的操作:\r\nos.access(path,mod) 判断对一个文件或者目录是否具有指定的权限\r\nmode 参数的可选值: ROK, WOK, 和 X_OK\r\n>>> os.access('/tmp',os.R_OK)\r\nTrue\r\n>>> os.access('/tmp',os.X_OK)\r\nTrue\r\n>>> os.access('/tmp',os.W_OK)\r\nTrue\r\nos.stat() 相当于对 Linux 下 stat 命令的一个封装\r\n>>> os.stat('/tmp')\r\nposix.stat_result(st_mode=17407, st_ino=259075, st_dev=2050L, st_nlink=18, st_uid=0, st_gid=0, st_size=4096, st_atime=1458681523, st_mtime=1458681528, st_ctime\r\n>>> s = os.stat('/tmp')\r\n>>> s.st_atime\r\n1458681523.5486367\r\n>>> s.st_uid\r\n0\r\n>>> s.st_size\r\n4096\r\nos.listdir() 列车给定目录的内容\r\n>>> os.listdir('/tmp')\r\n['orbit-gdm', 'ks-script-V5pzEo.log', 'vmware-walter', 'vmware-config0', 'vgauthsvclog.txt.0', 'pulse-kbdbaPr3T3eB', 'pulse-cbhCLNnWv5AJ', '.X11-unix', 'vmware\r\nos.mkdir(path) 创建目录\r\nos.mkdirs(path) 创建目录树,相当于mkdir -p 操作\r\n对于 OS 还有其他好多方法,具体可查看官方文档,接下来说下os.path 模块。\r\nos.pathos.path 是os 的一个子模块 , 主要是对路径进行解析、创建、测试和其他的一些操作,封装了不同平台的路径操作。\r\n路径解析:\r\n>>> from os import path\r\n>>> path.split('/tmp/test/ab')# 讲路径切割成了 dirname 和 basename 。传入的路径可以不存在\r\n('/tmp/test', 'ab')\r\n>>> path.basename('/tmp/test/ab')\r\n'ab'\r\n# 直接返回 basename\r\n>>> path.dirname('/tmp/test/ab')\r\n'/tmp/test'\r\n# 返回 dirname\r\n.splitext(path) 解析扩展名\r\n>>> path.splitext('aaa.tar.gz')\r\n('aaa.tar', '.gz')\r\n将给定的字符连接成一个路径\r\n>>> path.join('a','b','c')\r\n'a/b/c'\r\n根据相对路径得到绝对路径:\r\n>>> path.abspath('.')\r\n'/root'\r\n>>> path.abspath('../tmp')\r\n'/tmp'\r\n>>> path.abspath('../tmp/test')\r\n'/tmp/test'\r\n文件属性相关\r\nos.path.getatime , os.path.getctime , os.path.getmtime , os.path.getsize\r\n示例:\r\n>>> from os import path\r\n>>> path.getatime('/tmp/test')\r\n1458683334.4796343\r\n文件测试\r\nos.path.isabs , os.path.isdir , os.path.isfile , os.path.islink 等等\r\n示例:\r\n>>> from os import path\r\n>>> path.isfile('/tmp/test')\r\nFalse\r\n>>> path.isdir('/tmp/test')\r\nTrue\r\n判断文件是否存在:\r\n>>> from os import path\r\n>>>\r\n>>> path.exists('/tmp/test')\r\nTrue\r\n>>> path.exists('/tmp/test2')\r\nFalse\r\nsys\r\n接下来再简单了解下 sys 模块,主要提供了系统相关的配置和操作,封装了探测、改变解释器 runtime 以及资源的交互。\r\n解释器相关信息:\r\nsys.version 得到解释器的版本信息\r\nsys.platform 得到当前运行平台,如 Linux , Windows 等>>> import sys\r\n>>> sys.platform\r\n'linux2'\r\n运行时环境 :\r\nsys.argv 获取传递给脚本的参数,参数解析类似于 bash 的方式,第一个参数代表脚本本身\r\n[root@localhost ~]# python arg.py 1 2 3 4 5\r\n['arg.py', '1', '2', '3', '4', '5']\r\n[root@localhost ~]# cat arg.py\r\n#!/usr/bin/env python\r\nimport sys\r\nprint sys.argv\r\n[root@localhost ~]#\r\nsys.stderr , sys.stdin , sys.stdout 这些都分别代表一个文件对象\r\n示例:\r\n[root@localhost ~]# cat err.py\r\n#!/usr/bin/env python\r\nimport sys\r\nprint >> sys.stderr,\"I am error\"\r\n# 执行脚本,并重定向标准输出和标准错误\r\n[root@localhost ~]# python err.py\r\nI am error\r\n[root@localhost ~]# python err.py > /tmp/1.log\r\nI am error\r\n[root@localhost ~]# cat /tmp/1.log\r\n[root@localhost ~]# python err.py 2> /tmp/1.log\r\n[root@localhost ~]# cat /tmp/1.log\r\nI am error\r\n# 解释清楚,为什么会出现上面的情形\r\n练习\r\n输出给定路径下的所有以 .log 结尾的文件\r\n#!/usr/bin/env python\r\nimport os\r\nimport sys\r\ndef findLogFile(path):\r\n'''find log file'''\r\nfor filename in os.listdir(path):\r\nif filename.endswith((\".log\",\".log.log\")):\r\nyield filename\r\nif __name__ == \"__main__\":\r\nfor f in findLogFile(sys.argv[1]):\r\nprint f\r\n[root@walter doc]# python dirlog.py /var/log/\r\nwpa_supplicant.log\r\nyum.log\r\nboot.log\r\n异常处理\r\n当程序运行过程中出错的时候,捕捉到该错误,并执行一些相应的自定义操作。\r\n用法:\r\ntry:\r\nexpression\r\nexcept [ex...]:\r\nexpression\r\n#try 语句有异常发生后执行 excepttry:\r\nexpression\r\nexcept:\r\nexpression\r\nfinally:\r\nexrepssion\r\n# 无论异常是否发生都会执行 finally 语句块\r\nraise error(message) 触发异常\r\nassert condition,message 当condition 表达式为 false 的时候触发一个异常,message 为要打印出的异常信息,触发异常后并终止程序\r\n简要的异常分类举例:\r\na[1] 如果 a 没有定义,则触发NameError\r\na=2;a[1] 此时会触发一个TypeError\r\na=[2];a[1] 触发一个IndexError\r\na={};a[1] 触发一个KeyError\r\nraise IndexError 触发一个异常\r\nassert False,\"error occur\" 条件触发一个异常 , 并打印异常信息\r\n示例:\r\nIn [1]: a[1]\r\n---------------------------------------------------------------------------\r\nNameError\r\nTraceback (most recent call last)\r\n<ipython-input-1-3ef3908cabc7> in <module>()\r\n----> 1 a[1]\r\nNameError: name 'a' is not defined\r\n# 由于并没有定义变量 a, 所以会触发一个 NameError 的异常\r\n# 后边的就是打印出的异常信息\r\n使用raise 手动触发一个NameError 异常:\r\nIn [2]: raise NameError(\"Oops,error\")\r\n---------------------------------------------------------------------------\r\nNameError\r\nTraceback (most recent call last)\r\n<ipython-input-2-baf5611c9528> in <module>()\r\n----> 1 raise NameError(\"Oops,error\")\r\nNameError: Oops,error\r\n在程序中手动产生异常:\r\n#!/usr/bin/env python\r\ntry:\r\na = [0,1]\r\nprint a[1]\r\n#raise IndexError(\"error\")# 如果执行了这一句,则下一句的 assert 语句就不会执行\r\nassert a[1] == 0,\"assert error\"\r\nexcept Exception,e:\r\nprint \"except:\"\r\nprint e\r\nfinally:\r\nprint \"finally\"\r\n#finally 是一个可选的语句块,但是在有些情况下最好要有的,\r\n# 比如打开了一个文件,对文件进行操作,不管异常是否出现都必须得关闭文件。\r\n提高篇\r\n数据结构\r\n前面已经讲过了 Python 内置的几个数据结构: list,set,dict,tuple\r\n下边要介绍一些非内置的数据结构。以标准库的形式提供。\r\n案例 1 ,需要处理一个日志文件,当前文件的某一行包含你指定的关键字时,你需要返回这一行的前 N 行内容。\r\n这种情况在监控日志的时候经常有此需求,比如你监控某个服务产生的日志,当某一行出现了 \"exception\" 关键字,但仅仅看到 exception 这一行,对运维来说\r\n帮助并不大;这个时候你就需要输出这一行的前面几行的日志内容用来分析。\r\nPython 实现了一个高效的deque 模块,实现双向队列,可以从两端入队或者出队。\r\ndeque 是 Python 的一个标准库,是由 C 语言开发而成,所以它的效率相当高。\r\n先简单查看下该模块的帮助信息:\r\nIn [1]: from collections import deque\r\nIn [2]: help(deque)\r\nclass deque(__builtin__.object)\r\n| deque([iterable[, maxlen]]) --> deque object\r\n|\r\n| Build an ordered collection with optimized access from its endpoints.\r\n|\r\n| Methods defined here:\r\n# 由帮助信息,可以简单的看到,该模块的构造函数接收两个可选参数, iterable 一个可迭代的元素,若指定这个参数, deque 模块会将该元素指定的值添加到队列中; maxlen 参数,该参数指定队列的最大长度\r\n具体实现代码:\r\n#!/usr/bin/env python\r\nimport sys\r\nfrom collections import deque # 引入 deque 队列模块\r\ndef search(f,pattern,keepNum):\r\n''' if find keywords,return the line and preLines'''\r\npreLines = deque(maxlen=keepNum)# 定义该队列所能保存的最大长度\r\nfor line in f:\r\n# 如果当前行包含指定的关键字,就返回当前行,和队列中保存的数据\r\nif pattern in line:\r\nyield line,preLines\r\npreLines.append(line)# 如果当前行没有包含指定的关键字,将当前行保存到队列中\r\nif __name__ == '__main__':\r\nlogFile = sys.argv[1]\r\npattern = sys.argv[2]\r\nkeepNum = int(sys.argv[3])\r\nwith open(logFile) as f:\r\n#search 此时是一个生成器函数,直接遍历即可\r\nfor line,preLines in search(f,pattern,keepNum):\r\n# 循环输出队列中保存的内容,也就是所匹配到的行的前 N 行的内容\r\nfor pline in preLines:\r\nprint pline\r\n# 输出当前所匹配到行的内容\r\nprint line\r\nprint '****'*10\r\n# 执行该脚本\r\n[root@walter doc]# python dq.py /var/log/messages Shutdown 5\r\n案例 2 、\r\n有一些 task ,需要保存到字典中, key 为名称, value 为内容,但是执行的时候,需要保持存储时的顺序\r\n解决思路:要是使用正常的字典话,将数据保存到字典中,但是读出数据的时候,次序将是无法预测的,及正常的字典返回数据的时候是无序的。\r\nOrderedDict 有序字典 , 可以按照保存数据的顺序来存储数据。\r\n正常字典无序验证:\r\nIn [1]: dic = dict()\r\nIn [2]: dic['foo'] = 1\r\nIn [3]: dic['bar'] = 2\r\nIn [4]: dic['fizz'] = 3\r\nIn [5]: dic['tom'] = 180In [6]: dic['jerry'] = 250\r\nIn [7]: dic\r\nOut[7]: {'bar': 2, 'fizz': 3, 'foo': 1, 'jerry': 250, 'tom': 180}# 可以看到输出数据的时候并不是保存数据时候的顺序了\r\nIn [8]: dic.keys()\r\nOut[8]: ['tom', 'foo', 'bar', 'jerry', 'fizz']#key 也是无序保存\r\nIn [9]: dic.values()\r\nOut[9]: [180, 1, 2, 250, 3]# 值也是无序的\r\nOrderedDict 有序字典:\r\nIn [10]: from collections import OrderedDict\r\nIn [11]: od = OrderedDict()\r\nIn [12]: od['foo'] = 1\r\nIn [13]: od['bar'] = 2\r\nIn [14]: od['fizz'] = 3\r\nIn [15]: od['tom'] = 180\r\nIn [16]: od\r\nOut[16]: OrderedDict([('foo', 1), ('bar', 2), ('fizz', 3), ('tom', 180)])# 数据的顺序就是当时保存的时候的顺序\r\nIn [17]: od.keys()\r\nOut[17]: ['foo', 'bar', 'fizz', 'tom']#key 是有序的\r\nIn [18]: od.values()\r\nOut[18]: [1, 2, 3, 180]# 值也是有序的\r\n这个模块一般应用在,某些数据输出的时候,需要与保存的顺序一致。\r\n案例 3\r\n统计一篇文章中出现频率最高的前 10 个单词,(英文文章)\r\nCounter 模块,是字典的一个子类,用来计数的一个模块。接收一个序列作为初始化参数。它有一个方法为most_common() 出现次数最多的前 N 项。\r\n#!/usr/bin/enc python\r\nimport sys\r\nimport re\r\nfrom collections import Counter\r\nwith open(sys.argv[1]) as f:\r\n# 注意这里一次读入全部的内容\r\nworlds = re.findall(r\"\\w+\",f.read().lower())\r\nprint Counter(worlds).most_common(10)\r\n[root@walter doc]# python c.py /var/log/messages\r\n[('walter', 4062), ('mar', 4058), ('27', 3700), ('kernel', 2926), ('17', 1902), ('29', 1877), ('06', 1731), ('48', 1631), ('0', 1488), ('42', 1174)]\r\n案例 4\r\n需要从一个 CSV 的文件里读入数据, CSV 文件的第一行是字段名,希望读入的数据可以根据字段名来访问。\r\nPython 的标准库里面已经提供了一个解决方案,namedtuple 命名元组 , 而且标准库里也提供了针对 csv 操作的模块 m csv .\r\nIn [1]: import csv\r\nIn [2]: from collections import namedtuple\r\nIn [3]: reader = csv.reader(open('./t.csv'))# 打开 csv 文件,生成一个 csv 的 reader 对象 , 找个对象就是一个迭代器\r\nIn [4]: fieds = reader.next() # 先读取迭代器中第一个元素,也就是 csv 文件中的第一行内容\r\nIn [5]: fieds\r\nOut[5]: ['name', 'gender', 'age', 'salary']# 会将每一行的内容按照分隔符 \",\" 拆分成一个 list, 即每行内容都会拆分成一个 list\r\nIn [6]: Contact = namedtuple(\"Contact\",fieds)# 生成一个明明元组 , 第一个参数 \"Contact\" 可以与中等号左边的变量名称不一样\r\nIn [7]: ContactOut[7]: __main__.Contact\r\nIn [8]: type(Contact)# 它的类型还是 type\r\nOut[8]: type\r\nIn [9]: c = Contact(*reader.next())# 继续迭代下一行内容。此时读取出来的应该是 csv 文件中的第二行内容,是一个 list\r\nIn [10]: c.name\r\nOut[10]: 'walt0er'\r\nIn [11]: c.gender\r\nOut[11]: '1'\r\nIn [12]: c.salary\r\nOut[12]: '1000002'\r\nIn [13]: type(c) #c 的类型为 Contact\r\nOut[13]: __main__.Contact\r\n# 查看 namedtuple 帮助,并解释\r\nnamedtuple(typename, field_names, verbose=False, rename=False)\r\n# 由此可以看出, namedtuple 的构造函数,第一个参数为类型名,\r\n# 也就是说命名元组其实是创造了一个新的类型出来;\r\n# 第二个参数为字段名,相当于这个新造出来的类型的属性名;\r\n# 后边两个是可选参数\r\nReturns a new subclass of tuple with named fields.\r\n>>> Point = namedtuple('Point', ['x', 'y'])\r\n>>> Point.__doc__\r\n# docstring for the new class\r\n'Point(x, y)'\r\n>>> p = Point(11, y=22)\r\n# instantiate with positional args or keywords\r\n>>> p[0] + p[1]\r\n# indexable like a plain tuple\r\n33\r\n>>> x, y = p\r\n# unpack like a regular tuple\r\n>>> x, y\r\n(11, 22)\r\n>>> p.x + p.y\r\n# fields also accessable by name\r\n33\r\n>>> d = p._asdict()\r\n# convert to a dictionary\r\n>>> d['x']\r\n11\r\n>>> Point(**d)\r\n# convert from a dictionary\r\nPoint(x=11, y=22)\r\n>>> p._replace(x=100)\r\n# _replace() is like str.replace() but targets named fields\r\nPoint(x=100, y=22)\r\n# 再看一下创造出来的那个 Contact 到底是个什么样的类型:\r\nclass Contact(__builtin__.tuple)\r\n| Contact(name, gender, age, salary)\r\n|# 由此可见 Contact 是 tuple 的一个子类,其构造函数需要四个参数,这四个参数也就是 CSV 文件的第一行内容,生成 Contact 类型的时候传递进来的。\r\n| Method resolution order:\r\n|\r\nContact\r\n|\r\n__builtin__.tuple\r\n|\r\n__builtin__.object\r\n|\r\n| Methods defined here:\r\n# 完整的脚本代码:\r\n#!/usr/bin/env python\r\nimport sys\r\nimport csv\r\nfrom collections import namedtuple\r\ncontacts = list()# 空列表用来保存最后的结果\r\nwith open(sys.argv[1],'rv') as f:\r\nreader = csv.reader(f)\r\nContact = namedtuple(\"Contact\",reader.next())\r\nfor line in reader:\r\ncontacts.append(Contact(*line))\r\nprint contacts\r\n[root@walter doc]# python n.py t.csv\r\n[Contact(name='walt0er', gender='1', age='100', salary='1000002'), Contact(name='wal9ter', gender='1', age='100', salary='1000002'), Contact(name='walter', ge运维相关\r\n文件目录操作\r\n之前已经介绍过一些 Python 对文件的操作,这里从运维的角度再了解下。\r\nos 模块。\r\n创建目录,os.mkdir\r\nIn [4]: import os\r\nIn [5]: os.mkdir('/tmp/testdir',0644)#0644 创建目录的权限\r\nIn [6]: ll /tmp/\r\ntotal 16\r\n-rw-r--r--. 1 root\r\n-rw-r--r--. 1 root\r\n-rw-r--r--. 1 root\r\ndrw-r--r--. 2 root\r\n-rw-r--r--. 1 root\r\n12\r\n12\r\n77\r\n6\r\n66\r\nApr\r\nApr\r\nApr\r\nApr\r\nApr\r\n3\r\n3\r\n3\r\n6\r\n3\r\n01:29\r\n01:29\r\n05:40\r\n07:03\r\n01:43\r\nerror.log\r\nout.log\r\ntest2.log\r\ntestdir/\r\ntest.log\r\n递归创建目录。类似mkdir -p 操作,os.makedirs\r\nIn [8]: os.makedirs('/tmp/t1/t2/t3')\r\n删除目录,os.rmdir\r\nIn [11]: os.rmdir('/tmp/testdir/')\r\nos 模块中暂时没有提供删除非空目录的操作。\r\n修改权限,os.chmod , 类似于chmod 命令\r\nIn [13]: os.chmod('/tmp/t1',0777)\r\nIn [14]: ll -d /tmp/t1\r\ndrwxrwxrwx. 3 root 15 Apr\r\n6 07:06 /tmp/t1/\r\nos.chown\r\nIn [17]: os.chown('/tmp/t1',500,500)# 后边两个参数分别为 UID 和 GID\r\nIn [18]: ll -d /tmp/t1\r\ndrwxrwxrwx. 3 500 15 Apr\r\n6 07:06 /tmp/t1/\r\nos.stat 与stat 命令一样\r\nIn [19]: os.stat('/tmp/t1')\r\nOut[19]: posix.stat_result(st_mode=16895, st_ino=17822857, st_dev=64768L, st_nlink=3, st_uid=500, st_gid=500, st_size=15, st_atime=1459897900, st_mtime=1459897\r\n其他相关方法os.getlogin() , os.getgid() , os.getuid() , os.getpid() 等\r\nshutil 模块介绍\r\n该模块简单来说是用来复制、归档文件和目录的。\r\nshutil.copyfile(src,dst) 复制一个文件\r\nshutil.copymod(src,dst) 复制文件权限 , 将文件权限同步到其他文件\r\nshutil.copy(src,dst) 源必须是文件,但是 dst 可以是文件或者目录,与cp 类似\r\nIn [24]: shutil.copy('tdir','/tmp/')#tdir 为目录\r\n---------------------------------------------------------------------------\r\nIOError\r\nTraceback (most recent call last)\r\n<ipython-input-24-bdbceda15912> in <module>()\r\n----> 1 shutil.copy('tdir','/tmp/')\r\n/usr/lib64/python2.7/shutil.pyc in copy(src, dst)\r\n117\r\nif os.path.isdir(dst):\r\n118\r\ndst = os.path.join(dst, os.path.basename(src))\r\n--> 119\r\ncopyfile(src, dst)\r\n120\r\ncopymode(src, dst)\r\n121/usr/lib64/python2.7/shutil.pyc in copyfile(src, dst)\r\n80\r\nraise SpecialFileError(\"`%s` is a named pipe\" % fn)\r\n81\r\n---> 82\r\nwith open(src, 'rb') as fsrc:\r\n83\r\nwith open(dst, 'wb') as fdst:\r\n84\r\ncopyfileobj(fsrc, fdst)\r\nIOError: [Errno 21] Is a directory: 'tdir'\r\n#copy 文件\r\nIn [29]: shutil.copy('anaconda-ks.cfg','/tmp/')\r\nIn [30]: ls /tmp/\r\nanaconda-ks.cfg error.log\r\nout.log\r\nt1/\r\ntest2.log\r\ntest.log\r\nshutil.copy2(src,dst) 与 copy 类似,但是源数据也会复制,类似cp -p 命令,将权限 , 时间戳等源数据也复制过去。\r\nshutil.copytree(src,dst) 以copy2 的方式递归复制一个目录:\r\nIn [5]: shutil.copytree('/tmp/t1','/tmp/dirt')\r\nIn [6]: ls /tmp/dirt/\r\nt2/\r\nshutil.rmtree(path) 递归删除一个目录\r\nIn [7]: shutil.rmtree('/tmp/dirt')\r\nIn [8]: ls /tmp/dirt\r\nls: cannot access /tmp/dirt: No such file or directory\r\n下面简单说一个从 2.7 版本shutil 才开始有的新功能 :\r\nshutil.make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None) 以什么样\r\n的格式打包, basename: 打包后的文件名称, format: 以什么样的格式打包, rootdir 压缩的根目录。 base_dir 开始压缩的目录。 rootdir 和 basedir 默认都是当前\r\n目录。\r\nIn [12]: shutil.make_archive('testarch','bztar','/tmp/t1')\r\nOut[12]: '/root/doc/testarch.tar.bz2'\r\n查看都支持哪些打包格式:\r\nIn [13]: shutil.get_archive_formats()\r\nOut[13]:\r\n[('bztar', \"bzip2'ed tar-file\"),\r\n('gztar', \"gzip'ed tar-file\"),\r\n('tar', 'uncompressed tar file'),\r\n('zip', 'ZIP file')]\r\n使用 Python 执行 Linux 命令\r\nos.system , 并没有返回值,是靠副作用产生输出的\r\nIn [15]: os.system('ls -l')\r\ntotal 24\r\n-rw-r--r--. 1 root root 191 Mar 29 07:24 c.py\r\n-rw-r--r--. 1 root root 262 Mar 31 05:57 dirlog.py\r\n-rw-r--r--. 1 root root 527 Mar 27 06:44 dq.py\r\n-rw-r--r--. 1 root root 276 Mar 29 07:55 n.py\r\n-rw-r--r--. 1 root root 459 Mar 29 07:35 t.csv\r\n-rw-r--r--. 1 root root 157 Apr 8 07:00 testarch.tar.bz2\r\nOut[15]: 0#ipython 中 out 表示返回值 , 可见 os.system 返回的是执行命令的退出状态码\r\n不需要命令返回值的时候,可以使用此函数。\r\nos.popen 返回一个文件对象\r\nIn [16]: p = os.popen('ls')\r\nIn [17]: p\r\nOut[17]: <open file 'ls', mode 'r' at 0x29fe810>\r\nIn [18]: p.read()\r\nOut[18]: 'c.py\\ndirlog.py\\ndq.py\\nn.py\\nt.csv\\ntestarch.tar.bz2\\n'\r\nos.popen2 返回两个文件对象,一个是 stdin, 一个是 stdoutos.popen3 返回三个文件对象 :stdin,stdout,stderr\r\n>>> i,o,e = os.popen3('ls /tmp2222')# 一个不存在的目录\r\n>>> i.read()\r\nTraceback (most recent call last):\r\nFile \"<stdin>\", line 1, in <module>\r\nIOError: File not open for reading\r\n>>> o.read()\r\n''\r\n>>> e.read()\r\n'ls: cannot access /tmp2222: No such file or directory\\n'\r\nos.popen4 返回两个文件对象, stdin,stderr 和 stdout 的合并\r\n>>> i,o = os.popen4('ls /tmp2222')\r\n>>> o.read()\r\n'ls: cannot access /tmp2222: No such file or directory\\n'\r\n就目前来看 os.popen4 貌似已经满足日常需求了,但是目前的话, popen 这组函数已经被标记会废弃的函数了,以后某个版本中可能就不存在这些函数了。\r\nIn [3]: os.popen3('ls /tmp222')\r\n/usr/bin/ipython:1: DeprecationWarning: os.popen3 is deprecated.\r\n#!/usr/bin/python\r\nUse the subprocess module.# 表明已标记为废弃,推荐使用 subprocess\r\n在 Python 中推荐使用subprocess 模块来执行命令,以上的几个函数都可以通过subprocess 模块里的某个方法来模拟。\r\nsubprocess.Popen(args, stdin=None, stdout=None, stderr=None, shell=False) 这里面只列出几个常用的参数:\r\nargs 需要执行的命令,可以是一个序列,如['ls','-l'] , 也可以是一个字符串 , 如ls -l\r\nstdin , stdout , stderr 后边跟一个文件对象,将相应的输出重定向到指定的文件中。\r\nshell 默认为 False, 当为 True 的时候表示打开一个 shell 进程来执行相关的命令。\r\n示例:\r\nIn [6]: p = subprocess.Popen(['ls','-l'],stdout=open('/tmp/out','w'))# 将标准输出保存到文件中\r\nIn [7]: p\r\nOut[7]: <subprocess.Popen at 0x1818310>\r\nIn [8]: p.returncode\r\nIn [9]: p.wait()# 执行该函数,以使命令执行完毕\r\nOut[9]: 0\r\nIn [10]: p.returncode# 返回命令执行后的退出码\r\nOut[10]: 0\r\n# 输出结果\r\nIn [11]: cat /tmp/out\r\ntotal 712\r\n-rw-------. 1 root root\r\n996 Mar 24 06:57 anaconda-ks.cfg\r\ndrwxr-xr-x. 2 root root\r\n91 Apr 8 07:00 doc\r\ndrwxr-xr-x. 7 root root\r\n60 Apr 3 18:31 python\r\n-rw-r--r--. 1 root root 722768 Mar 24 07:11 setuptools-20.3.1.zip\r\ndrwxr-xr-x. 2 root root\r\n6 Apr 6 07:33 tdir\r\n但是这种方式在日常工作中显的并不那么优雅,每次都要再读取文件,才能获取命令执行的结果。\r\n示例 2 :\r\nIn [12]: p = subprocess.Popen(['ls','-l'],stdout=subprocess.PIPE)#subprocess.PIPE\r\n# 默认情况下 shell=False,Popen 函数会将 args 参数序列的第一个元素作为可执行程序,\r\n# 其他元素作为其参数执行。\r\nIn [13]: p\r\nOut[13]: <subprocess.Popen at 0x1818110>\r\nIn [14]: p.stdout.read()# 读取命令执行结果\r\nOut[14]: 'total 712\\n-rw-------. 1 root root\r\n注意,以上执行的时候,shell 参数默认都是 False 。\r\n示例 3:\r\n996 Mar 24 06:57 anaconda-ks.cfg\\ndrwxr-xr-x. 2 root root\r\n91 Apr\r\n8 07:00 doc\\ndrwxr-xr-x. 7 root rootIn [15]: p = subprocess.Popen(['ls','-l'],stdout=subprocess.PIPE,shell=True)#shell=True 打开一个 shell 执行命令\r\nIn [16]: p.std\r\np.stderr p.stdin\r\np.stdout\r\nIn [16]: p.stdout.read()# 由返回的结果可以得知,\r\n# 当 shell=True 的时候, args 参数为序列的时候,只会执行序列的第一项。 ['ls','-l'] 只执行了 ls\r\nOut[16]: 'anaconda-ks.cfg\\ndoc\\npython\\nsetuptools-20.3.1.zip\\ntdir\\n'\r\n示例 4 :\r\nIn [17]: p = subprocess.Popen('ls -l',stdout=subprocess.PIPE,shell=True)\r\nIn [18]: p.stdout.read()\r\n#shell=True,args 为字符串的时候 :'ls -l', 将整个字符串作为命令执行\r\nOut[18]: 'total 712\\n-rw-------. 1 root root\r\n996 Mar 24 06:57 anaconda-ks.cfg\\ndrwxr-xr-x. 2 root root\r\n91 Apr\r\n8 07:00 doc\\ndrwxr-xr-x. 7 root root\r\n示例 5 :\r\n[19]: p = subprocess.Popen('ls -l',stdout=subprocess.PIPE)\r\n# 这种情况会报错,因为 shell=False 的时候,会将整个字符串作为一个可执行程序执行,\r\n# 但此时肯定找不到名为 'ls -l' 的可执行程序\r\n总之,当 shell=True 的时候,会调用系统当前 shell 来执行命令。如 RHEL 下的默认 shell 为 bash 。一般工作上都将 shell 设置为 True ,可以执行 Linux 下的命令,\r\n如当命令中带有管道符 \"|\" 的时候。\r\n在上边的示例中,都是使用p.wait() 函数来等待命令结束的,有时候使用该函数在 Linux 下会产生死锁的现象。stdout=subporcess.PIPE 会在内存中开辟一\r\n个空间来保存命令执行的结果,这个空间是最大为 64K ,但是当命令执行的输出结果大于 64K 的时候,p.wait() 会一直等待下去。\r\n示例:\r\n[root@walter ~]# ulimit -a\r\n...\r\nmax locked memory\r\n(kbytes, -l) 64# 最大锁内存为 64K\r\n...\r\n# 产生死锁\r\nIn [12]:cmd = 'dd if=/dev/zero bs=1K count=64 2>/dev/null'# 将错误重定向,只保留标准输出 , 产生一个 64K 大小的输出\r\nIn [13]: p = subprocess.Popen(cmd,stdout=subprocess.PIPE,shell=True)\r\nIn [14]: p.wait()# 执行结果输出为 64K 大小的时候, wait 正常执行\r\nOut[14]: 0\r\n# 大于 64K\r\nIn [16]: cmd = 'dd if=/dev/zero bs=1K count=65 2>/dev/null'\r\nIn [17]: p = subprocess.Popen(cmd,stdout=subprocess.PIPE,shell=True)\r\nIn [18]: p.wait()# 为 65K 的时候, wait 会一直等待下去\r\n# 这种情况必须得使用 p.communicate 函数,该函数返回两个值 (stdout,stderr)\r\nIn [22]: p = subprocess.Popen(cmd,stdout=subprocess.PIPE,shell=True)\r\nIn [23]: o,e = p.communicate()\r\nIn [24]: e\r\nIn [25]: p.returncode\r\nOut[25]: 0\r\n执行命令的一个高阶模块:\r\nsh 这是一个第三方模块,可以将任意 Linux 命令作为 Python 的函数来执行,命令参数作为其参数传入:sh.ls('-l') , 函数返回值是命令的执行结\r\n果 . sh.ifconfig() 。\r\n进程管理\r\npsutil 是一个第三方模块,需要单独安装 : easy_install psutil\r\npsutil.users() 获取当前系统中登录的用户:\r\nIn [4]: psutil.users()\r\nOut[4]: [suser(name='root', terminal='pts/0', host='10.25.0.1', started=1460238720.0)]\r\npsutil.boot_time() 获取系统启动时间\r\n获取 CPU 使用百分比:\r\nIn [6]: psutil.cpu_percent()Out[6]: 0.4\r\n获取 CPU 核数:\r\nIn [7]: psutil.cpu_count()\r\nOut[7]: 1\r\n获取 CPU 使用的百分比:与top 命令获取的是一样的\r\nIn [10]: psutil.cpu_times_percent()\r\nOut[10]: scputimes(user=0.1, nice=0.0, system=0.2, idle=99.7, iowait=0.0, irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)\r\n获取内存信息:\r\nIn [11]: psutil.virtual_memory()\r\nOut[11]: svmem(total=1025363968, available=816713728, percent=20.3, used=328347648, free=697016320, active=129585152, inactive=81391616, buffers=970752, cached\r\n获取某个分区使用情况:\r\nIn [19]: psutil.disk_usage('/')\r\nOut[19]: sdiskusage(total=13914603520, used=1362849792, free=12551753728, percent=9.8)\r\nglances 这个监控程序就是基于 psutil 这个模块开发的。\r\n与进程相关的操作方法:\r\nIn [20]: p = psutil.process_iter()\r\n# 以迭代器的形式返回系统中所有的进程\r\nIn [21]: p\r\nOut[21]: <generator object process_iter at 0x2be3fa0>\r\nIn [22]: a = p.next()\r\nIn [23]: a# 返回的第一个进程\r\nOut[23]: <psutil.Process(pid=1, name='systemd') at 46177488>\r\nIn [24]: a.\r\na.as_dict\r\na.is_running\r\na.pid\r\na.children\r\na.kill\r\na.ppid\r\na.cmdline\r\na.memory_full_info a.resume\r\na.connections\r\na.memory_info\r\na.rlimit\r\na.cpu_affinity\r\na.memory_info_ex\r\na.send_signal\r\na.cpu_percent\r\na.memory_maps\r\na.status\r\na.cpu_times\r\na.memory_percent\r\na.suspend\r\na.create_time\r\na.name\r\na.terminal\r\na.cwd\r\na.nice\r\na.terminate\r\na.environ\r\na.num_ctx_switches a.threads\r\na.exe\r\na.num_fds\r\na.uids\r\na.gids\r\na.num_threads\r\na.username\r\na.io_counters\r\na.open_files\r\na.wait\r\na.ionice\r\na.parent\r\n# 针对某个进程所支持的操作\r\nIn [28]: a.exe()# 当前进程的执行程序\r\nOut[28]: '/usr/lib/systemd/systemd'\r\nIn [30]: a.cpu_times()# 当前进程 CPU 时间的使用\r\nOut[30]: pcputimes(user=0.25, system=1.79, children_user=1.22, children_system=2.3)\r\nIn [31]: a.pid# 进程 ID\r\nOut[31]: 1\r\n/proc 文件系统\r\nLinux 系统为管理员提供了非常好的方法,使其可以在系统运行时更改内核,而不需要重新引导内核系统,这是通过 /proc 虚拟文件系统实现的。 /proc 文件\r\n虚拟系统是一种内核和内核模块用来向进程( process )发送信息的机制(所以叫做 “/proc” ),这个伪文件系统允许与内核内部数据结构交互,获取有关进程\r\n的有用信息,在运行中( on the fly )改变设置(通过改变内核参数)。与其他文件系统不同, /proc 存在于内存而不是硬盘中。 proc\r\n文件系统提供的信息如下:\r\n进程信息:系统中的任何一个进程,在 proc 的子目录中都有一个同名的进程 ID ,可以找到 cmdline 、 mem 、 root 、 stat 、 statm ,以及 status 。某些信\r\n息只有超级用户可见,例如进程根目录。每一个单独含有现有进程信息的进程有一些可用的专门链接,系统中的任何一个进程都有一个单独的自链接指\r\n向进程信息,其用处就是从进程中获取命令行信息。\r\n系统信息:如果需要了解整个系统信息中也可以从 /proc/stat 中获得,其中包括 CPU 占用情况、磁盘空间、内存对换、中断等。\r\nCPU 信息:利用 /proc/CPUinfo 文件可以获得中央处理器的当前准确信息。\r\n负载信息: /proc/loadavg 文件包含系统负载信息。\r\n系统内存信息: /proc/meminfo 文件包含系统内存的详细信息,其中显示物理内存的数量、可用交换空间的数量,以及空闲内存的数量等。/proc 目录中的主要文件的说明\r\n只简单列出几个经常用到监控中的文件\r\n/proc/cpuinfo CPU 信息\r\n/proc/loadavg 系统平均负载信息\r\n/proc/meminfo 内存相关信息,包括物理内存和交换分区\r\n/proc/swaps 交换分区使用情况\r\n案例 1 :读取负载信息\r\n#!/usr/bin/env python\r\ndef load_avg():\r\nloadavg = {}\r\nwith open('/proc/loadavg') as f:\r\navg = f.read().split()# 将本行内容以空格分隔为列表\r\nloadavg['avg_1'] = avg[0]\r\nloadavg['avg_5'] = avg[1]\r\nloadavg['avg_15'] = avg[2]\r\nreturn loadavg\r\nif __name__ == '__main__':\r\nfor k,v in load_avg().items():\r\nprint k,v\r\n案例 2: 获取内存使用信息\r\n#!/usr/bin/env python\r\nfrom collections import OrderedDict\r\ndef meminfo():\r\n'''get memory info from /proc/meminfo'''\r\ninfo = OrderedDict()\r\n# 将读取到的所有内存信息存到一个有序字典里,\r\n# 这样的话,以后可以按照存储的顺序直接读取出来\r\nwith open('/proc/meminfo') as f:\r\nfor line in f:\r\nfields = line.split(':')\r\ninfo[fields[0]] = fields[1].strip()\r\nreturn info\r\nif __name__ == '__main__':\r\nmeminfo = meminfo()\r\nprint 'Total memory:{0}'.format(meminfo['MemTotal'])\r\nprint 'Free memory:{0}'.format(meminfo['MemFree'])\r\n案例 3 :监控 mariadb 进程是否存在\r\n#!/usr/bin/env python\r\nimport os\r\ndef is_mariadb_alive():\r\n''' monitor mariadb'''\r\nret = os.popen('ps -C mysqld -o pid,cmd').readlines()\r\nreturn False if len(ret) < 2 else True#python 中实现的类似三元表达式\r\nif __name__ == '__main__':\r\nprint is_mariadb_alive()\r\n# 此处也可以加些功能:\r\n# 如\r\n当返回为 False 的时候,表示 mariadb 进程不存在了\r\n# 此时需要启动 mariadb : os.system(\"service apache2 restart\")\r\n可能会用到的模块argparse , smtplib 。\r\npython 操作 MySQL 数据库\r\n安装\r\n[root@~]# yum install MySQL-python#ipython 或者 python shell 中测试可以正常导入\r\nIn [1]: import MySQLdb # 不报错,表示安装成功\r\n在本地书库创建一个库用于测试:\r\nMariaDB [(none)]> create database testpython;\r\nQuery OK, 1 row affected (0.00 sec)\r\n连接 MySQL 数据库:\r\nIn [1]: import MySQLdb\r\nIn [2]: conn = MySQLdb.connect(host='localhost',user='root',passwd='123456',db='testpython',port=3306,charset='utf8')\r\nhost : MySQL 数据库地址\r\nuser: 数据库登陆用户名\r\npasswd: 数据库登陆密码\r\ndb: 登陆数据库后,需要操作的库名\r\nport: 数据库监听端口,默认为 3306\r\ncharset: 数据库编码\r\n建立与数据库的连接,其实就是建立了一个MySQLdb.connect() 的实例对象 conn, 这个实例对象常用的操作有:\r\ncommit() 如果数据库表进行了修改,提交保存当前的数据。\r\nrollback() 如果有权限,就取消当前的操作,否则报错\r\ncursor() 游标指针。\r\n连接成功之后,就要开始操作数据库, MySQLdb 用游标 cursor 的方式操作数据库。\r\n# 创建一个数据库游标\r\nIn [3]: cur = conn.cursor()\r\n模块底层其实是调用 CAPI 的,所以,需要先得到当前指向数据库的指针。这也就提醒我们,在操作数据库的时候,指针会移动,如果移动到数据库最后一条\r\n了,再查,就查不出什么来了 .\r\n下面用 cursor() 提供的方法来进行操作,方法主要是 :\r\n1. 执行命令\r\n2. 接收结果\r\ncursor 执行命令的方法:\r\nexecute(query, args): 执行单条 sql 语句。 query 为 sql 语句本身, args 为参数值的列表。执行后返回值为受影响的行数。\r\nexecutemany(query, args): 执行单条 sql 语句 , 但是重复执行参数列表里的参数 , 返回值为受影响的行数\r\n首先在数据库创建一个用于测试:\r\nMariaDB [testpython]> create table member(id int(2) not null primary key auto_increment,username varchar(40),password varchar(20),email varchar(200))default ch\r\n# 建表语句\r\nCREATE TABLE `member` (\r\n`id` int(2) NOT NULL AUTO_INCREMENT,\r\n`username` varchar(40) DEFAULT NULL,\r\n`password` varchar(20) DEFAULT NULL,\r\n`email` varchar(200) DEFAULT NULL,\r\nPRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n插入一条数据,返回值为受影响的行数:\r\nIn [5]: cur.execute(\"insert into member (username,password,email) values (%s,%s,%s)\",(\"python\",\"123456\",\"python@gmail.com\"))\r\nOut[5]: 1L\r\n但是此时并没有完成表真正的 提交:\r\nMariaDB [testpython]> select * from member;\r\nEmpty set (0.00 sec)\r\n提交事务:\r\nIn [7]: conn.commit()\r\n数据成功被保存:\r\nMariaDB [testpython]> select * from member;+----+----------+----------+------------------+\r\n| id | username | password | email\r\n|\r\n+----+----------+----------+------------------+\r\n| 1 | python\r\n| 123456\r\n| python@gmail.com |\r\n+----+----------+----------+------------------+\r\n1 row in set (0.00 sec)\r\n插入多条数据:\r\n>>> cur.executemany(\"insert into member (username,password,email) values (%s,%s,%s)\",((\"google\",\"111222\",\"g@gmail.com\"),(\"facebook\",\"222333\",\"f@face.book\"),(\"g\r\n4L\r\n>>> conn.commit()\r\n日常工作中,大多数会先拼接一个 SQL 语句 然后再执行,实现插入数据的操作:\r\nIn [12]: sql = \"INSERT INTO member (username,password,email) values ('%s','%s','%s')\" % ('walter.liu','123456','zheshiz2@163.com')# 注意其中的字符串要带上引号 '%s'\r\nIn [13]: cur.execute(sql)\r\nOut[13]: 1L\r\nIn [14]: conn.commit()\r\n查询数据\r\n查询数据也需要用游标来操作\r\nIn [4]: cur.execute('select * from member')\r\nOut[4]: 2L # 表示有两条数据被检索出来\r\n使用游标一下方法,才能取回检索到的数据:\r\nfetchall(self): 接收全部的返回结果行 .\r\nfetchmany(size=None): 接收 size 条返回结果行 . 如果 size 的值大于返回的结果行的数量 , 则会返回 cursor.arraysize 条数据 .\r\nfetchone(): 返回一条结果行 .\r\nscroll(value, mode='relative'): 移动指针到某一行 . 如果 mode='relative', 则表示从当前所在行移动 value 条 , 如果 mode='absolute', 则表示从结果集的第一行\r\n移动 value 条\r\n实例:\r\nIn [5]: lines = cur.fetchall()\r\n# 取回的数据被放在一个大的元祖里,\r\n# 此时游标已经移动到最后一条数据了\r\n# 如果再执行一次 cur.fetchall() 会返回空\r\nIn [6]: lines\r\nOut[6]:\r\n((1L, u'python', u'123456', u'python@gmail.com'),\r\n(2L, u'walter.liu', u'123456', u'zheshiz2@163.com'))\r\n遍历取回的数据:\r\nIn [8]: for line in lines:\r\n...:\r\nprint line\r\n...:\r\n(1L, u'python', u'123456', u'python@gmail.com')\r\n(2L, u'walter.liu', u'123456', u'zheshiz2@163.com')\r\n更新数据:\r\nIn [11]: cur.execute('UPDATE member SET username=\"%s\" WHERE id=1' % ('php'))\r\nOut[11]: 1L\r\nIn [12]: cur.execute('SELECT * FROM member WHERE id=1')\r\nOut[12]: 1L\r\nIn [13]: cur.fetchone()\r\nOut[13]: (1L, u'php', u'123456', u'python@gmail.com')\r\n# 此时在 python 里看到数据已经被更新,但是在数据库中还没有被真正的更新\r\n# 需要执行 commit 提交事务才行\r\nIn [14]: conn.commit()# 将数据真正的更新到数据库中\r\n关于乱码问题:\r\n可以做如下统一设置:\r\nPython 文件设置编码 utf-8 (文件前面加上 #encoding=utf-8)MySQL 数据库 charset=utf8 (数据库的设置方法,可以网上搜索)\r\nPython 连接 MySQL 是加上参数 charset=utf8 (在前面教程中都这么演示了,很重要)\r\n设置 Python 的默认编码为 utf-8 (sys.setdefaultencoding(utf-8) ,)\r\nPython 程序:\r\n#encoding=utf-8\r\nimport sys\r\nimport MySQLdb\r\nreload(sys)\r\nsys.setdefaultencoding('utf-8')\r\ndb=MySQLdb.connect(user='root',charset='utf8')\r\nMySQL 配置:\r\n[client] default-character-set = utf8\r\n[mysqld] default-character-set = utf8\r\nflask 入门\r\n安装 flask\r\n[root@walter ~]# easy_install flask\r\n# 或者 pip install flask\r\n定义一个简单的页面: app.py 文件\r\n__author__ = 'liuzhenwei'\r\n# 导入 flask 模块\r\nfrom flask import Flask\r\n# 实例化一个 application 对象,将当前的模块名称传递进去\r\napp = Flask(__name__)\r\n# 在开发的时候 ,一般将 debug 设置为 true, 这样的话,修改程序文件后, app 会自动加载。\r\napp.debug = True\r\n# 在 flask 中使用装饰器的方式,将请求连接映射到相应的函数\r\n@app.route('/')\r\ndef hello():\r\nreturn 'hello world'\r\n#hello 称之为一个视图函数\r\nif __name__ == '__main__':\r\napp.run('0.0.0.0')\r\n# 运行上边声明的 app, 默认值为空表示,监听 127.0.0.1 的 500 端口\r\n# 在开一个终端运行\r\n[root@walter web]# python app.py\r\n* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)\r\n* Restarting with stat\r\n* Debugger is active!\r\n* Debugger pin code: 134-058-099\r\n浏览器打开 http://10.25.128.8:5000/ 。\r\n接下来以一个简单的博客形式,来讲解后续的内容。\r\n博客应有的基本功能:\r\n浏览博客\r\n发表博客\r\n这里使用 MySQL 数据库存储博客信息。\r\n库名为: blog\r\nposts 表,用来存储博客内容:\r\nCREATE TABLE `posts` (\r\n`id` int(11) NOT NULL AUTO_INCREMENT,\r\n`title` varchar(50) DEFAULT NULL,\r\n`content` text,\r\nPRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;发表一篇博客:\r\n相应的视图函数:\r\n这里需要一个 MySQL 的连接驱动,这个地方使用前面讲过的 MySQLdb 模块。\r\n在 app.py 文件中,新增一个视图函数\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\npass\r\n# 关于装饰器中的 methods 参数\r\n# 默认不指定的话,表示该连接只接受 GET 请求,\r\n# 这表示该连接接受 GET 和 POST 两个请求\r\n# 当用户以 GET 方式请求的时候,页面渲染一个 form 表单,用于发表博客\r\n# 当用户以 POST 方式请求的时候,表示用户要提交发表的博客内容\r\n下面丰富 add_entry 函数的功能:\r\n完整的代码为:\r\n[root@walter web]# cat app.py\r\n__author__ = 'liuzhenwei'\r\nfrom flask import Flask,request\r\nimport MySQLdb\r\napp = Flask(__name__)\r\napp.debug = True\r\n@app.route('/')\r\ndef hello():\r\nreturn 'hello world'\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\n# 根据 request 对象的 method 方法,获取当前请求的方式\r\nif request.method == 'GET':\r\n# 以 DOC 的形式返回一个 form 表单到页面上。\r\nreturn '''\r\n<html>\r\n<head>\r\n<title>My Blog</title>\r\n</head>\r\n<body>\r\n<form action='' method='POST'>\r\nTitle:<input type='text' name='title'>\r\n<br />\r\n<br />\r\nContent:<textarea name='content'></textarea>\r\n<br />\r\n<br />\r\n<input type='submit' value='Submit'>\r\n</form>\r\n</body>\r\n</html>\r\n'''\r\nif __name__ == '__main__':\r\napp.run('0.0.0.0')\r\n浏览器: http://10.25.128.8:5000/add\r\n到目前为止,页面也可以正常打开,但是此时我们是将 html 代码直接写到 python 函数内的,这种方式相当的傻了。这接下来将其修改为模板的形式。\r\n在当前目录下创建一个 templates 的目录。里面放置我们需要的 HTML 模板文件。\r\n[root@walter web]#\r\n[root@walter web]#\r\n[root@walter web]#\r\ntotal 4\r\n-rw-r--r--. 1 root\r\ndrwxr-xr-x. 2 root\r\nmkdir templates\r\nll\r\nroot 662 Apr 14 06:28 app.py\r\nroot\r\n6 Apr 14 06:32 templates\r\n在 flask 中是约定大于设置的,即 flask 会在 application 所在的目录下,找一个叫 templates 的目录,然后到此目录里找相应的模板文件。不需要在某个配置文件\r\n中对其进行设置。完整的代码修改为:\r\n__author__ = 'liuzhenwei'\r\n#render_template 用来加载模板文件\r\nfrom flask import Flask,request,render_template\r\nimport MySQLdb\r\napp = Flask(__name__)\r\napp.debug = True\r\n@app.route('/')\r\ndef hello():\r\nreturn 'hello world'\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\nif request.method == 'GET':\r\nreturn render_template('add_entry.html')\r\n#render_template 方法,接收一个模板文件名为参数\r\n# 表示当前要加载的模板文件\r\nif __name__ == '__main__':\r\napp.run('0.0.0.0')\r\nadd_entry 添加接收提交内容的功能:\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\nif request.method == 'GET':\r\nreturn render_template('add_entry.html')\r\nif request.method == 'POST':\r\ntitle = request.form.get('title')\r\ncontent = request.form.get('content')\r\nreturn '%s,%s' % (title,content)\r\n打开浏览器,提交内容测试,输入内容,提交,页面可以返回提交的内容表示正常。\r\n点击提交后:\r\n到目前为止,程序可以正常接收我们从页面提交的内容了,接下来需要将内容保存到数据库中:\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\nif request.method == 'GET':\r\nreturn render_template('add_entry.html')\r\nif request.method == 'POST':\r\ntitle = request.form.get('title')\r\ncontent = request.form.get('content')\r\n# 创建一个数据连接\r\nconn = MySQLdb.connect(host='localhost',user='root',passwd='',db='blog')\r\n# 创建游标cur = conn.cursor()\r\n# 拼接 SQL 语句\r\nsql = \"INSERT INTO posts (title,content) VALUES ('%s','%s')\" %(title,content)\r\n# 执行 SQL\r\ncur.execute(sql)\r\n# 提交事务\r\nconn.commit()\r\n# 关闭游标\r\ncur.close()\r\n# 关闭连接\r\nconn.close()\r\n# 在视图函数中,必须得 return 一个值,否则会报错\r\nif r is not None:\r\nreturn 'submit ok'\r\nelse:\r\nreturn 'submit error'\r\n提交测试:\r\n查看数据库:\r\nMariaDB [blog]> select * from posts;\r\n+----+-------+---------+\r\n| id | title | content |\r\n+----+-------+---------+\r\n| 1 | aaaa | dddddd |\r\n+----+-------+---------+\r\n1 row in set (0.00 sec)\r\n到目前为止,可以正常发表一篇文章了,接下来需要完成显示文章的列表。 新增 index 视图方法。\r\n@app.route('/')\r\ndef index():\r\nconn = MySQLdb.connect(host='localhost',user='root',passwd='',db='blog')\r\ncur = conn.cursor()\r\nsql = \"SELECT id,title FROM posts ORDER BY id DESC\"\r\ntry:\r\ncur.execute(sql)\r\nposts = cur.fetchall()\r\nexcept Exception,e:\r\nreturn e\r\nfinally:\r\ncur.close()\r\nconn.close()\r\nreturn render_template('index.html',posts=posts)# 渲染模板,并将数据传递到模板里\r\nindex.html 内容\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset='utf-8'>\r\n<title>MyBlog</title>\r\n</head>\r\n<body>\r\n<ul>\r\n<!--jinja2 模板语法 -->\r\n{% for post in posts %}\r\n<li>{{ post[1] }}</li>\r\n{% endfor %}\r\n</ul>\r\n</body>\r\n</html>\r\n浏览器打开,访问首页:显示博客详情页面:\r\n@app.route('/detail')\r\ndef detail():\r\n# 接收从 URL 以 GET 方式传递的值,需要用 request.args\r\np_id = request.args.get('id')\r\nconn = MySQLdb.connect(host='localhost',user='root',passwd='',db='blog')\r\ncur = conn.cursor()\r\nsql = \"SELECT id,title,content FROM posts WHERE id=%d\" % int(p_id)\r\ntry:\r\ncur.execute(sql)\r\npost = cur.fetchone()\r\nexcept Exception,e:\r\nreturn e\r\nfinally:\r\ncur.close()\r\nconn.close()\r\nreturn render_template('detail.html',post=post)\r\n创建模板文件: detail.html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset='utf-8'>\r\n<title>{{ post[1] }}</title>\r\n</head>\r\n<body>\r\n<h2>{{ post[1] }}</h2>\r\n<hr>\r\n<p>\r\n{{ post[2] }}\r\n</p>\r\n</body>\r\n</html>\r\n浏览器打开页面:\r\nhttp://10.25.128.8:5000/detail?id=2 ,这种方式是以 query string 的方式传递的参数,看起来不是那么好看,对搜索引擎也是不是很友好。我们平时见到的好\r\n多连接基本上都是 : http://10.25.128.8:5000/detail/2 这种方式:\r\n修改视图函数:\r\n#<int:p_id> 表示一个占位符, int 表示此处变量的类型, p_id 变量名,占位符如果不加类型,默认为 str\r\n@app.route('/detail/<int:p_id>')\r\n# 直接以参数的形式传递给视图函数\r\ndef detail(p_id):\r\n#p_id = request.args.get('id')# 这一行不再需要\r\nconn = MySQLdb.connect(host='localhost',user='root',passwd='',db='blog')\r\ncur = conn.cursor()\r\nsql = \"SELECT id,title,content FROM posts WHERE id=%d\" % int(p_id)\r\ntry:\r\ncur.execute(sql)\r\npost = cur.fetchone()except Exception,e:\r\nreturn e\r\nfinally:\r\ncur.close()\r\nconn.close()\r\nreturn render_template('detail.html',post=post)\r\n浏览器打开\r\nhttp://10.25.128.8:5000/detail/2\r\n修改列表也,加上链接:\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset='utf-8'>\r\n<title>MyBlog</title>\r\n</head>\r\n<body>\r\n<ul>\r\n<!--jinja2 模板语法 -->\r\n{% for post in posts %}\r\n<li><a href='{{ url_for('detail',p_id=post[0])}}'>\r\n<!-- 这里的 url_for 可以根据提供的视图函数,反向解除对应的 URL 链接。后边直接跟要传递的参数即可 , 这样的话,无论视图函数里面的路由路径怎么变,都会根据视\r\n{{ post[1] }}</a></li>\r\n{% endfor %}\r\n</ul>\r\n</body>\r\n</html>\r\n到目前为止,基本的博客功能是实现了,但是在视图函数中,每个函数都有一个数据库连接的操作,过于重复。修改的时候也很麻烦,不符合当代编程的规\r\n范。\r\n在 flask 中有两个较为有用的视图函数:\r\n@app.before_request : 在 request 请求之前执行 , 在此处添加数据库连接操作\r\n@app.teardown_request :在视图函数执行结束后,执行改段代码,在此处关闭数据库连接\r\n@app.before_request\r\ndef connect_db():\r\napp.app_ctx_globals_class.conn = MySQLdb.connect(host='localhost',user='root',passwd='',db='blog')\r\napp.app_ctx_globals_class.cur = app.app_ctx_globals_class.conn.cursor()\r\n@app.teardown_request\r\ndef close_db(*args):\r\n# 该函数需要接受一个参数,为当前刚结束的请求的 request\r\nif hasattr( app.app_ctx_globals_class,'cur'):\r\napp.app_ctx_globals_class.cur.close()\r\nif hasattr( app.app_ctx_globals_class,'conn'):\r\napp.app_ctx_globals_class.conn.close()\r\napp.app_ctx_globals_class 为 flask app 中一个全局的对象。添加了上边两个函数,其他视图函数中的数据库连接和数据库关闭操作都可以删除掉了。\r\n到目前为止,所有的 SQL 语句都是硬编码写的,非常不友好。下边使用 flask-SQLAlchemy ORM-- 对象关系映射\r\n安装:\r\n[root@walter web]# easy_install flask-SQLAlchemy\r\n在 app.py 中引入模块 :\r\nfrom flask.ext.sqlalchemy import SQLAlchemy\r\n使用 ORM 连接数据库:SQLALCHEMY_DATABASE_URI=\"mysql+pymysql://root:@localhost:3306/blog\"\r\n# 格式: mysql+pymysql://USERNAME:PASSWD@HOST:PORT/DBNAME\r\napp.config.from_object(__name__)# 从当前模块中导入数据库配置 URI\r\ndb = SQLAlchemy(app)# 实例化一个数据库对象\r\n# 定义一个 model\r\nclass Post(db.Model):\r\n__tablename__ = 'posts'\r\nid = db.Column(db.Integer,primary_key=True,autoincrement=True)\r\ntitle = db.Column(db.String(45),unique=True,nullable=False)\r\ncontent = db.Column(db.Text,nullable=True)\r\n# 修改所有的视图函数,主要修改操作数据库的代码\r\napp.route('/')\r\ndef index():\r\nposts = Post.query.all()\r\nreturn render_template('index.html',posts=posts)\r\n@app.route('/detail/<int:p_id>')\r\ndef detail(p_id):\r\npost = Post.query.filter_by(id=p_id).first()\r\nreturn render_template('detail.html',post=post)\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\nif request.method == 'GET':\r\nreturn render_template('add_entry.html')\r\nif request.method == 'POST':\r\ntitle = request.form.get('title')\r\ncontent = request.form.get('content')\r\npost = Post()\r\npost.title = title\r\npost.content = content\r\ndb.session.add(post)\r\ntry:\r\ndb.session.commit()\r\nexcept Exception,e:\r\ndb.session.rollback()\r\nreturn redirect(url_for('index'))\r\n# 跳转到首页 ,from flask import redirect,url_for\r\n相应的模板函数,也要修改,因为这次传递给模板的变量是一个对象:\r\n[root@walter web]# cat templates/index.html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset='utf-8'>\r\n<title>MyBlog</title>\r\n</head>\r\n<body>\r\n<ul>\r\n<!--jinja2 模板语法 -->\r\n{% for post in posts %}\r\n<li><a href='{{ url_for('detail',p_id=post.id)}}'>{{ post.title }}</a></li>\r\n{% endfor %}\r\n</ul>\r\n</body>\r\n</html>\r\n[root@walter web]# cat templates/detail.html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset='utf-8'>\r\n<title>{{ post.title }}</title>\r\n</head>\r\n<body>\r\n<h2>{{ post.title }}</h2>\r\n<hr>\r\n<p>\r\n{{ post.content }}\r\n</p></body>\r\n</html>\r\n完整的代码:\r\n[root@walter web]# cat app.py\r\n__author__ = 'liuzhenwei'\r\nfrom flask import Flask,request,render_template,redirect,url_for\r\nfrom flask.ext.sqlalchemy import SQLAlchemy\r\nimport sys\r\napp = Flask(__name__)\r\napp.debug = True\r\nSQLALCHEMY_DATABASE_URI=\"mysql://root:@localhost:3306/blog\"\r\napp.config.from_object(__name__)\r\ndb = SQLAlchemy(app)\r\nclass Post(db.Model):\r\n__tablename__ = 'posts'\r\nid = db.Column(db.Integer,primary_key=True,autoincrement=True)\r\ntitle = db.Column(db.String(45),unique=True,nullable=False)\r\ncontent = db.Column(db.Text,nullable=True)\r\n@app.route('/')\r\ndef index():\r\nposts = Post.query.all()\r\nreturn render_template('index.html',posts=posts)\r\n@app.route('/detail/<int:p_id>')\r\ndef detail(p_id):\r\npost = Post.query.filter_by(id=p_id).first()\r\nreturn render_template('detail.html',post=post)\r\n@app.route('/add',methods=['GET','POST'])\r\ndef add_entry():\r\nif request.method == 'GET':\r\nreturn render_template('add_entry.html')\r\nif request.method == 'POST':\r\ntitle = request.form.get('title')\r\ncontent = request.form.get('content')\r\npost = Post()\r\npost.title = title\r\npost.content = content\r\ndb.session.add(post)\r\ntry:\r\ndb.session.commit()\r\nexcept Exception,e:\r\ndb.session.rollback()\r\nreturn redirect(url_for('index'))\r\nif __name__ == '__main__':\r\n# 第一次运行此程序的时候需要创建表,使用上边的 db 对象即可,可以根据定义好的每个 model 类,创建相应的表\r\nif len(sys.argv)>=2 and sys.argv[1]=='setup':\r\ndb.create_all()\r\nsys.exit(0)\r\n#drop 所有的表\r\nif len(sys.argv)>=2 and sys.argv[1]=='drop':\r\ndb.drop_all()\r\nsys.exit(0)\r\napp.run('0.0.0.0')",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}